{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sovereign Agent Template (SAGT)","text":"<p>SAGT is a governance framework for AI coding agents. It defines how authority is structured, how execution is constrained, and how architectural drift is prevented.</p> <p>SAGT does not define product architecture. It defines how architecture is allowed to be defined.</p> <p>The framework exists because modern AI agents are generative but not inherently governed. They infer. They generalize. They optimize locally. Without structured constraint, this behavior creates architectural entropy.</p> <p>SAGT introduces layered authority:</p> <ul> <li>Canon (law)</li> <li>Task Groups (intent classification)</li> <li>Skills (procedural execution)</li> <li>Specs (temporal control)</li> <li>Policy (runtime drift detection)</li> </ul> <p>Each layer is isolated. Each boundary is explicit. Each violation results in refusal or escalation.</p> <p>SAGT assumes that ambiguity is dangerous. It assumes that silent reconciliation of conflicting rules produces long-term instability. It treats refusal not as failure, but as integrity preservation.</p> <p>The framework is deterministic by design. Given the same canon, same spec, and same inputs, execution should converge to equivalent results. If determinism cannot be guaranteed, execution must halt.</p> <p>SAGT is not a productivity tool. It is governance infrastructure.</p> <p>Its purpose is to make AI-assisted development stable, predictable, and auditable across time and across models.</p>"},{"location":"execution-flow/","title":"Execution Lifecycle","text":"<p>SAGT execution is deterministic and ordered.</p> <p>Every request passes through the same governance pipeline. No step may be skipped. No step may be reordered.</p> <p>This structure ensures that authority is evaluated before action.</p>"},{"location":"execution-flow/#step-1-task-group-classification","title":"Step 1 \u2014 Task Group Classification","text":"<p>Every request must map to exactly one Task Group.</p> <p>Task Groups define intent boundaries. Examples include: - Architecture - Implementation - Governance Maintenance - Canon Mutation</p> <p>If classification is ambiguous, execution halts.</p> <p>Mixed classification is forbidden because it collapses separation of concerns.</p>"},{"location":"execution-flow/#step-2-canon-state-validation","title":"Step 2 \u2014 Canon State Validation","text":"<p>Before any planning or execution:</p> <ul> <li>Canon precedence is evaluated.</li> <li>Protected zones are checked.</li> <li>Mutation locks are verified.</li> <li>Compiler status must be valid.</li> </ul> <p>If contradictions exist, execution stops.</p> <p>The system never executes against an unstable canon state.</p>"},{"location":"execution-flow/#step-3-spec-requirement-determination","title":"Step 3 \u2014 Spec Requirement Determination","text":"<p>Non-trivial work requires a Spec.</p> <p>Spec includes: - requirements.md - design.md - tasks.md</p> <p>Trivial work may bypass spec only if explicitly allowed by canon.</p> <p>Spec introduces temporal control. It prevents architecture from emerging implicitly during execution.</p>"},{"location":"execution-flow/#step-4-human-validation-gate-if-required","title":"Step 4 \u2014 Human Validation Gate (if required)","text":"<p>If: - Protected zones are touched, - Architecture changes are proposed, - Canon mutation is involved,</p> <p>The agent emits:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Execution stops immediately.</p> <p>No speculative continuation is permitted.</p>"},{"location":"execution-flow/#step-5-task-execution","title":"Step 5 \u2014 Task Execution","text":"<p>Tasks execute strictly within:</p> <ul> <li>Canon constraints</li> <li>Task Group boundaries</li> <li>Skill authority limits</li> </ul> <p>Skills cannot introduce new invariants. Skills cannot reinterpret canon. Skills execute only defined procedure.</p> <p>If a skill encounters undefined authority, it halts.</p>"},{"location":"execution-flow/#step-6-telemetry-logging","title":"Step 6 \u2014 Telemetry Logging","text":"<p>Every execution produces structured telemetry:</p> <ul> <li>Task Group used</li> <li>Skills activated</li> <li>Refusals triggered</li> <li>Canon citations referenced</li> <li>Policy metrics impacted</li> </ul> <p>Governance without observability is incomplete.</p> <p>Telemetry enables policy enforcement.</p>"},{"location":"execution-flow/#step-7-policy-evaluation","title":"Step 7 \u2014 Policy Evaluation","text":"<p>Policy thresholds are evaluated:</p> <ul> <li>Refusal frequency</li> <li>Shadow pattern detection</li> <li>Mutation frequency</li> <li>TTL flags</li> <li>Escalation counts</li> </ul> <p>If thresholds are exceeded, execution halts.</p> <p>Policy does not override canon. It detects drift patterns.</p>"},{"location":"execution-flow/#step-8-handover-update","title":"Step 8 \u2014 Handover Update","text":"<p>If execution is incomplete:</p> <p>.jtasks/HANDOVER.md must be updated.</p> <p>Handover includes: - Current Task Group - Canon version - Spec status - Pending steps - Last refusal trigger - Policy status snapshot</p> <p>This ensures continuity across sessions and across models.</p>"},{"location":"execution-flow/#failure-conditions","title":"Failure Conditions","text":"<p>Execution halts immediately if:</p> <ul> <li>Canon conflict detected</li> <li>Task Group ambiguity exists</li> <li>Protected zone touched improperly</li> <li>Mutation incomplete</li> <li>Compiler failure</li> <li>Determinism cannot be guaranteed</li> </ul> <p>Halting preserves structural integrity.</p>"},{"location":"execution-flow/#why-this-lifecycle-exists","title":"Why This Lifecycle Exists","text":"<p>Without ordered execution:</p> <ul> <li>Planning and execution merge.</li> <li>Architecture evolves implicitly.</li> <li>Security assumptions drift.</li> <li>Mutation becomes invisible.</li> <li>Multi-model continuity collapses.</li> </ul> <p>The lifecycle is the enforcement spine of SAGT.</p> <p>It guarantees that authority is evaluated before action.</p>"},{"location":"overview/","title":"Overview","text":"<p>AI coding agents are powerful but structurally unstable. They are trained on patterns, not on authority hierarchies. They will introduce solutions that appear correct even when they violate implicit architectural constraints.</p> <p>This produces drift.</p> <p>Drift happens in three primary ways:</p> <ol> <li>Pattern imitation \u2014 adopting structures from training bias.</li> <li>Incremental creep \u2014 small changes that alter system invariants over time.</li> <li>Ambiguity resolution \u2014 silently choosing one interpretation when rules are unclear.</li> </ol> <p>SAGT prevents drift by separating execution authority into layered domains.</p> <p>Canon defines non-negotiable rules. Task Groups define intent boundaries. Skills define mechanical execution limits. Specs define ordered planning requirements. Policy evaluates systemic health over time.</p> <p>Each layer has a different purpose and different enforcement behavior.</p> <p>The system does not rely on agent goodwill. It relies on structural enforcement.</p> <p>If a request cannot be safely classified into exactly one Task Group, it is refused. If canon conflicts cannot be resolved by precedence, execution halts. If a skill attempts to introduce architecture, it stops.</p> <p>This structure transforms AI from a generative assistant into a governed actor.</p> <p>SAGT is designed to operate across models. It does not depend on one reasoning engine. It depends on documented authority.</p> <p>Governance must survive model switching, context resets, and time gaps. SAGT is built for continuity.</p>"},{"location":"principles/","title":"Foundational Principles","text":""},{"location":"principles/#1-authority-must-be-explicit","title":"1. Authority Must Be Explicit","text":"<p>Authority cannot be inferred. Every rule must declare its scope, precedence, and enforcement semantics.</p> <p>Implicit authority leads to silent override. Silent override leads to instability.</p> <p>SAGT forces every governing rule to exist in writing before it exists in execution.</p>"},{"location":"principles/#2-ambiguity-is-a-stop-condition","title":"2. Ambiguity Is a Stop Condition","text":"<p>AI systems tend to reconcile ambiguity. SAGT forbids this.</p> <p>If two rules appear to conflict and precedence does not clearly resolve the conflict, execution halts.</p> <p>Ambiguity is not resolved automatically because automatic reconciliation hides governance gaps.</p> <p>Stopping reveals incomplete law.</p>"},{"location":"principles/#3-refusal-preserves-integrity","title":"3. Refusal Preserves Integrity","text":"<p>Refusal is not error. It is boundary enforcement.</p> <p>A governed agent must refuse when: - Task classification is ambiguous. - Protected zones are touched improperly. - Canon conflicts exist. - Security assumptions are undefined.</p> <p>A system that never refuses is not governed.</p>"},{"location":"principles/#4-determinism-is-required","title":"4. Determinism Is Required","text":"<p>Given identical inputs and identical canon state, output should converge.</p> <p>Non-determinism signals hidden authority, unstated assumptions, or incomplete rule specification.</p> <p>SAGT treats non-deterministic outcomes as governance failures.</p>"},{"location":"principles/#5-mutation-is-formal-and-rare","title":"5. Mutation Is Formal and Rare","text":"<p>Canon may evolve, but evolution is structured.</p> <p>Changes require: - Explicit mutation specification - Impact analysis - Version increment - Human validation</p> <p>Ad-hoc rule changes undermine trust in the governance layer.</p>"},{"location":"principles/#6-separation-of-concerns-is-enforced","title":"6. Separation of Concerns Is Enforced","text":"<p>Architecture, implementation, governance, and mutation are distinct domains.</p> <p>They must never collapse into a single execution path.</p> <p>Blurring these boundaries reintroduces drift.</p> <p>SAGT enforces separation structurally, not culturally.</p>"},{"location":"canon/","title":"Canon","text":"<p>Canon is the highest authority layer in SAGT.</p> <p>It defines the non-negotiable rules that govern agent behavior, architectural integrity, and enforcement semantics.</p> <p>Canon is not advisory documentation. Canon is law.</p> <p>Everything below canon \u2014 Task Groups, Skills, Specs, Policy \u2014 operates within its constraints.</p>"},{"location":"canon/#why-canon-exists","title":"Why Canon Exists","text":"<p>AI systems drift by default.</p> <p>They adopt patterns from training data. They resolve ambiguity silently. They optimize locally rather than structurally.</p> <p>Without a defined authority layer, architecture evolves implicitly.</p> <p>Canon prevents this by:</p> <ul> <li>Declaring invariants explicitly</li> <li>Defining enforcement semantics</li> <li>Defining precedence order</li> <li>Establishing protected zones</li> <li>Requiring mutation for change</li> </ul> <p>Canon is the anti-drift mechanism.</p>"},{"location":"canon/#what-canon-contains","title":"What Canon Contains","text":"<p>Canonical documents typically include:</p> <ul> <li>Architecture Rules</li> <li>Security Model</li> <li>Precedence Index</li> <li>Terminology</li> <li>Decisions</li> <li>Enforcement Matrix</li> </ul> <p>Each document must define:</p> <ul> <li>Scope</li> <li>Authority level</li> <li>Enforcement behavior</li> <li>Precedence relationship</li> </ul> <p>Canon must not rely on implied authority.</p>"},{"location":"canon/#canon-precedence","title":"Canon Precedence","text":"<p>Canon has explicit precedence ordering.</p> <p>Higher precedence overrides lower precedence.</p> <p>If two rules conflict and precedence does not resolve the conflict:</p> <p>Execution halts.</p> <p>SAGT does not permit agents to reconcile equal-precedence conflicts. Ambiguity reveals incomplete governance.</p>"},{"location":"canon/#canon-invariants","title":"Canon Invariants","text":"<p>Canon must satisfy the following invariants:</p> <ol> <li>Every rule must declare scope.</li> <li>Every rule must declare enforcement behavior.</li> <li>No rule may implicitly override another.</li> <li>Precedence must be deterministic.</li> <li>Canon must be versioned.</li> <li>Mutation must be traceable.</li> </ol> <p>If any invariant is violated, canon is unstable.</p> <p>Execution must halt until stability is restored.</p>"},{"location":"canon/#enforcement-semantics","title":"Enforcement Semantics","text":"<p>Canon must define enforcement explicitly.</p> <p>Examples of enforcement behaviors:</p> <ul> <li>refuse</li> <li>escalate</li> <li>warn</li> <li>require-mutation</li> <li>require-hitl</li> </ul> <p>Prose without enforcement semantics is incomplete.</p> <p>SAGT distinguishes between explanatory language and enforceable rules.</p> <p>Prose explains intent. Structured rule blocks encode authority.</p>"},{"location":"canon/#canon-vs-documentation","title":"Canon vs Documentation","text":"<p>Not all documentation is canon.</p> <p>Canon is:</p> <ul> <li>Normative</li> <li>Binding</li> <li>Enforced</li> </ul> <p>Informational documents may explain system design but do not override canon.</p> <p>The boundary must remain clear.</p> <p>Confusing explanation with law creates shadow authority.</p>"},{"location":"canon/#canon-compilation","title":"Canon Compilation","text":"<p>Canon may include structured rule blocks (e.g., YAML).</p> <p>These are extracted and validated by the Canon Compiler.</p> <p>The compiler:</p> <ul> <li>Validates schema</li> <li>Detects contradictions</li> <li>Detects circular overrides</li> <li>Builds enforcement graph</li> <li>Generates enforcement matrix</li> </ul> <p>Compilation failure halts execution.</p> <p>Canon must be structurally valid before it can govern.</p>"},{"location":"canon/#canon-failure-modes","title":"Canon Failure Modes","text":"<p>Canon becomes unstable if:</p> <ul> <li>Equal-precedence conflict exists</li> <li>Enforcement behavior is undefined</li> <li>Protected zones lack clarity</li> <li>Overrides create cycles</li> <li>Mutation introduces ambiguity</li> </ul> <p>When canon is unstable:</p> <p>No execution may proceed.</p> <p>The agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Canon integrity precedes productivity.</p>"},{"location":"canon/#canon-and-time","title":"Canon and Time","text":"<p>Canon is versioned.</p> <p>Each mutation increments version.</p> <p>Execution logs must record canon version used.</p> <p>This enables:</p> <ul> <li>Historical auditability</li> <li>Multi-model continuity</li> <li>Reproducibility</li> <li>Regression analysis</li> </ul> <p>Canon without versioning cannot guarantee determin</p>"},{"location":"canon/ARCHITECTURE_INDEX/","title":"ARCHITECTURE_INDEX","text":"<p>This file defines the canonical document set for SAGT and how it is interpreted.</p> <p>It is an index of law, not a description of features.</p> <p>If a document is not listed here as canonical, it must be treated as non-canonical unless a higher-precedence rule states otherwise.</p> <p>This index exists to prevent \u201cshadow canon\u201d and to ensure that authority is explicit and reviewable.</p>"},{"location":"canon/ARCHITECTURE_INDEX/#1-canonical-precedence-order","title":"1. Canonical Precedence Order","text":"<p>The following precedence order is mandatory.</p> <p>Higher precedence documents override lower precedence documents.</p> <p>If two documents at the same precedence level conflict and no higher rule resolves the conflict, execution MUST halt and require human validation.</p> <ol> <li><code>src/canon/ARCHITECTURE_RULES.md</code></li> <li><code>src/canon/SECURITY_MODEL.md</code></li> <li><code>src/canon/ARCHITECTURE_INDEX.md</code></li> <li><code>src/canon/DECISIONS.md</code></li> <li><code>src/canon/TERMINOLOGY.md</code></li> <li><code>src/canon/DOC_STYLE.md</code></li> <li><code>src/canon/ENFORCEMENT_MATRIX.md</code></li> </ol> <p>Notes: - <code>src/canon/index.md</code> is an explanatory overview and must not override any of the above. - Files outside <code>src/canon/</code> are non-canonical unless explicitly stated.</p>"},{"location":"canon/ARCHITECTURE_INDEX/#2-canon-scope","title":"2. Canon Scope","text":"<p>Canon governs:</p> <ul> <li>Agent behavior constraints</li> <li>Authority boundaries and enforcement semantics</li> <li>Refusal and escalation conditions</li> <li>Mutation process requirements</li> <li>Protected zone definitions</li> <li>Rule schema and compiler behavior (if enabled)</li> </ul> <p>Canon does not govern:</p> <ul> <li>Product architecture</li> <li>Technology stack choices</li> <li>Domain models for downstream projects</li> <li>Implementation preferences unless explicitly declared</li> </ul>"},{"location":"canon/ARCHITECTURE_INDEX/#3-canon-integrity-requirements","title":"3. Canon Integrity Requirements","text":"<p>A canon set is valid only if:</p> <ul> <li>All listed canonical files exist.</li> <li>Precedence order is unambiguous.</li> <li>No equal-precedence conflicts exist without explicit resolution.</li> <li>Enforcement semantics are defined for normative rules.</li> <li>Protected zones are declared where required.</li> </ul> <p>If these conditions are not met, the agent MUST halt and emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p>"},{"location":"canon/ARCHITECTURE_INDEX/#4-non-canonical-convenience-files","title":"4. Non-Canonical Convenience Files","text":"<p>The following file types are explicitly non-canonical:</p> <ul> <li><code>docs/</code> build output (GitHub Pages artifacts)</li> <li><code>src/**/README.md</code> unless explicitly declared canonical</li> <li><code>src/**/index.md</code> overview pages unless explicitly declared canonical</li> <li><code>src/**/MINI_CANON.md</code> summaries (if present)</li> <li>Any generated reports unless explicitly added to canon via mutation</li> </ul> <p>Non-canonical files may explain, summarize, or guide, but may not override canonical documents.</p>"},{"location":"canon/ARCHITECTURE_INDEX/#5-cross-reference-rules","title":"5. Cross-Reference Rules","text":"<p>Canon documents should cross-reference each other via relative links.</p> <p>When a document defines a term or mechanism that is referenced elsewhere, it should link to:</p> <ul> <li><code>TERMINOLOGY.md</code> for definitions</li> <li><code>ENFORCEMENT_MATRIX.md</code> for enforcement behavior</li> <li><code>ARCHITECTURE_RULES.md</code> for invariants and constraints</li> <li><code>SECURITY_MODEL.md</code> for trust and privilege boundaries</li> <li><code>DECISIONS.md</code> for recorded rationale</li> </ul> <p>Cross-references reduce interpretation drift and support deterministic execution.</p>"},{"location":"canon/ARCHITECTURE_INDEX/#6-amendment-policy","title":"6. Amendment Policy","text":"<p>Changes to canonical documents require Canon Mutation.</p> <p>Mutation must:</p> <ul> <li>Declare the specific file(s) changed</li> <li>Declare the exact rule impact</li> <li>Include an impact analysis</li> <li>Require human validation</li> <li>Increment canon version tracking (see <code>DECISIONS.md</code>)</li> </ul> <p>Canon must never change implicitly as a side effect of execution.</p> <p>This file is authoritative for what \u201ccanon\u201d means in SAGT.</p>"},{"location":"canon/ARCHITECTURE_RULES/","title":"ARCHITECTURE_RULES","text":"<p>This document defines the highest-precedence invariants for SAGT.</p> <p>These rules are binding.</p> <p>Agents must refuse when these rules are violated or when compliance is ambiguous.</p> <p>This document governs governance. It does not govern downstream application architecture.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a1-canon-precedence-is-mandatory","title":"Rule A1 \u2014 Canon Precedence Is Mandatory","text":"<p>Canonical precedence order must be followed as declared in <code>ARCHITECTURE_INDEX.md</code>.</p> <p>Agents must not reinterpret precedence or \u201cmerge\u201d conflicting rules.</p> <p>If precedence does not resolve a conflict, the agent must halt and emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a2-one-task-group-per-execution","title":"Rule A2 \u2014 One Task Group per Execution","text":"<p>Every request must be classified into exactly one task group.</p> <p>Mixed task groups are forbidden.</p> <p>If classification is ambiguous, execution must halt and require human validation.</p> <p>Task groups define authority scope and must be treated as an intent firewall.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a3-skills-are-procedural-only","title":"Rule A3 \u2014 Skills Are Procedural Only","text":"<p>Skills may execute only deterministic procedures.</p> <p>Skills must not:</p> <ul> <li>Introduce architecture</li> <li>Modify canon</li> <li>Modify invariants</li> <li>Fill missing security boundaries</li> <li>Interpret ambiguous canon</li> </ul> <p>If a skill requires design judgment, it must stop.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a4-spec-first-for-non-trivial-work","title":"Rule A4 \u2014 Spec-First for Non-Trivial Work","text":"<p>Non-trivial work requires spec artifacts:</p> <ul> <li>requirements.md</li> <li>design.md</li> <li>tasks.md</li> </ul> <p>Execution begins only after explicit human instruction.</p> <p>If a request is non-trivial and no spec exists, the agent must halt and require spec generation.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a5-refusal-is-enforced","title":"Rule A5 \u2014 Refusal Is Enforced","text":"<p>Refusal is required when:</p> <ul> <li>Canon conflicts exist</li> <li>Task group classification is ambiguous</li> <li>Protected zones would be modified without mutation</li> <li>Security model is undefined or lacks evidence</li> <li>Determinism cannot be guaranteed</li> <li>Compiler validation fails (if enabled)</li> </ul> <p>Refusal must be explicit and must stop execution.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a6-protected-zones-are-immutable-without-mutation","title":"Rule A6 \u2014 Protected Zones Are Immutable Without Mutation","text":"<p>Protected zones define structural invariants and security boundaries.</p> <p>Protected zones cannot be modified by:</p> <ul> <li>Skills</li> <li>Implementation tasks</li> <li>Routine documentation updates</li> </ul> <p>Any modification requires Canon Mutation and human validation.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a7-mutation-is-the-only-legal-canon-change","title":"Rule A7 \u2014 Mutation Is the Only Legal Canon Change","text":"<p>Canon may only change through formal mutation.</p> <p>Mutation must include:</p> <ul> <li>Proposal</li> <li>Impact analysis</li> <li>Human validation</li> <li>Version traceability</li> </ul> <p>Any attempt to \u201cjust update the docs\u201d that modifies authority is a violation.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a8-no-shadow-architecture","title":"Rule A8 \u2014 No Shadow Architecture","text":"<p>Agents must not introduce structural patterns not authorized by canon.</p> <p>If a pattern is needed:</p> <ul> <li>remove it, or</li> <li>initiate a canon mutation to authorize it</li> </ul> <p>Silent adoption is prohibited.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a9-determinism-is-required","title":"Rule A9 \u2014 Determinism Is Required","text":"<p>Given the same canon version, spec, and inputs, outputs must converge structurally.</p> <p>If determinism cannot be guaranteed due to ambiguity or missing authority, execution must halt.</p>"},{"location":"canon/ARCHITECTURE_RULES/#rule-a10-hitl-break-glass-marker-is-mandatory","title":"Rule A10 \u2014 HITL Break-Glass Marker Is Mandatory","text":"<p>When execution must pause for validation, the agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>The marker must appear on its own line.</p> <p>After emitting it, the agent must not continue execution.</p> <p>These rules define the non-negotiable architecture of governance in SAGT.</p>"},{"location":"canon/DECISIONS/","title":"DECISIONS","text":"<p>This file records canonical decisions and version traceability.</p> <p>It exists to provide rationale for governance changes and to enable auditability.</p> <p>Decisions recorded here are canonical but lower precedence than Architecture Rules and Security Model.</p>"},{"location":"canon/DECISIONS/#decision-log-format","title":"Decision Log Format","text":"<p>Each entry should include:</p> <ul> <li>Decision ID</li> <li>Date</li> <li>Canon version affected</li> <li>Summary</li> <li>Rationale</li> <li>Alternatives considered</li> <li>Impact</li> <li>Links to mutation spec (if applicable)</li> </ul>"},{"location":"canon/DECISIONS/#d-001-establish-canon-precedence-model","title":"D-001 \u2014 Establish Canon Precedence Model","text":"<p>Date: 2026-02-16 Canon Version: 1.0  </p> <p>Summary: SAGT establishes explicit canonical precedence ordering.</p> <p>Rationale: Without explicit precedence, conflicts are resolved by interpretation. Interpretation causes drift.</p> <p>Alternatives: - No precedence, rely on \u201cbest judgement\u201d (rejected) - Majority voting between docs (rejected)</p> <p>Impact: Agents must halt on unresolved conflicts and require HITL.</p>"},{"location":"canon/DECISIONS/#d-002-enforce-hitl-marker-as-machine-detectable-stop","title":"D-002 \u2014 Enforce HITL Marker as Machine-Detectable Stop","text":"<p>Date: 2026-02-16 Canon Version: 1.0  </p> <p>Summary: Define <code>[AWAIT_HUMAN_VALIDATION]</code> as mandatory stop marker.</p> <p>Rationale: Manual \u201cSTOP\u201d language is not reliably machine-detectable. A stable marker enables tooling and CI gating.</p> <p>Alternatives: - Natural language pauses (rejected) - Multiple markers (rejected)</p> <p>Impact: All workflows requiring pause must use the marker.</p>"},{"location":"canon/DECISIONS/#decision-maintenance","title":"Decision Maintenance","text":"<p>New decisions must be appended.</p> <p>If a decision becomes obsolete, it must not be deleted. Instead, mark it as superseded with a reference to the newer decision.</p> <p>This preserves audit history.</p>"},{"location":"canon/DOC_STYLE/","title":"DOC_STYLE","text":"<p>This document defines writing rules for canonical documents.</p> <p>Canonical docs must be readable by humans and enforceable by tools.</p> <p>Style is not cosmetic. It reduces ambiguity.</p>"},{"location":"canon/DOC_STYLE/#1-normative-language","title":"1. Normative Language","text":"<p>Canonical rules must use clear modal verbs:</p> <ul> <li>MUST</li> <li>MUST NOT</li> <li>SHOULD (rare; only where explicitly non-binding)</li> <li>MAY (rare; only where explicitly optional)</li> </ul> <p>Avoid vague phrasing such as: - \u201ctry to\u201d - \u201cgenerally\u201d - \u201cit would be best\u201d - \u201cideally\u201d</p> <p>Ambiguity triggers refusal.</p>"},{"location":"canon/DOC_STYLE/#2-rule-formatting","title":"2. Rule Formatting","text":"<p>Rules should be numbered and titled.</p> <p>Each rule should include:</p> <ul> <li>statement</li> <li>scope</li> <li>enforcement outcome (or reference to Enforcement Matrix)</li> </ul> <p>If enforcement is not defined, the rule is incomplete.</p>"},{"location":"canon/DOC_STYLE/#3-prose-vs-law","title":"3. Prose vs Law","text":"<p>Canonical prose may explain intent, but cannot override rules.</p> <p>If a prose paragraph conflicts with a rule statement, the rule wins.</p>"},{"location":"canon/DOC_STYLE/#4-cross-references","title":"4. Cross-References","text":"<p>When referencing another canonical doc:</p> <ul> <li>link to the exact file</li> <li>prefer section anchors if stable</li> <li>avoid duplicating rules in multiple documents</li> </ul> <p>Duplication increases conflict risk.</p>"},{"location":"canon/DOC_STYLE/#5-change-discipline","title":"5. Change Discipline","text":"<p>Any modification to canonical documents requires mutation.</p> <p>Minor wording changes can alter enforcement interpretation. Therefore, canon changes are never casual.</p>"},{"location":"canon/DOC_STYLE/#6-non-canonical-documents","title":"6. Non-Canonical Documents","text":"<p>Non-canonical files must include a clear disclaimer:</p> <p>\u201cNon-canonical. Canon prevails.\u201d</p> <p>This prevents accidental authority elevation.</p> <p>This document exists to prevent governance drift through language ambiguity.</p>"},{"location":"canon/ENFORCEMENT_MATRIX/","title":"ENFORCEMENT_MATRIX","text":"<p>This document defines enforcement behavior for canonical rules.</p> <p>Its purpose is to make refusal, escalation, and mutation requirements explicit and machine-checkable.</p> <p>If a rule is normative and has no enforcement semantics, the canon is incomplete.</p>"},{"location":"canon/ENFORCEMENT_MATRIX/#1-enforcement-actions","title":"1. Enforcement Actions","text":"<p>The following enforcement actions are permitted:</p> <ul> <li>REFUSE: Stop execution and refuse request.</li> <li>HITL: Stop execution and emit <code>[AWAIT_HUMAN_VALIDATION]</code>.</li> <li>REQUIRE_MUTATION: Stop execution and require Canon Mutation workflow.</li> <li>WARN: Proceed but emit a warning (must be rare and explicitly allowed).</li> <li>BLOCK: Hard stop due to compiler/canon invalidity.</li> </ul> <p>Actions must be explicit. Agents must not invent enforcement.</p>"},{"location":"canon/ENFORCEMENT_MATRIX/#2-severity-levels","title":"2. Severity Levels","text":"<p>Severity indicates how strictly the action must be applied:</p> <ul> <li>CRITICAL: Must halt immediately.</li> <li>HIGH: Must halt unless explicitly waived by higher precedence.</li> <li>MEDIUM: May halt depending on context if canon allows.</li> <li>LOW: Warn-only if canon allows.</li> </ul> <p>Default severity is forbidden. Severity must be declared.</p>"},{"location":"canon/ENFORCEMENT_MATRIX/#3-core-rule-enforcement","title":"3. Core Rule Enforcement","text":""},{"location":"canon/ENFORCEMENT_MATRIX/#a1-canon-precedence-is-mandatory","title":"A1 \u2014 Canon Precedence Is Mandatory","text":"<ul> <li>Action: HITL</li> <li>Severity: CRITICAL</li> <li>Trigger: Any unresolved canon conflict or precedence ambiguity</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a2-one-task-group-per-execution","title":"A2 \u2014 One Task Group per Execution","text":"<ul> <li>Action: HITL</li> <li>Severity: CRITICAL</li> <li>Trigger: Task classification ambiguous or mixed intent</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a3-skills-are-procedural-only","title":"A3 \u2014 Skills Are Procedural Only","text":"<ul> <li>Action: REFUSE</li> <li>Severity: CRITICAL</li> <li>Trigger: Skill attempts architecture or judgment beyond procedure</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a4-spec-first-for-non-trivial-work","title":"A4 \u2014 Spec-First for Non-Trivial Work","text":"<ul> <li>Action: HITL</li> <li>Severity: HIGH</li> <li>Trigger: Non-trivial work requested without spec artifacts</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a5-refusal-is-enforced","title":"A5 \u2014 Refusal Is Enforced","text":"<ul> <li>Action: REFUSE</li> <li>Severity: CRITICAL</li> <li>Trigger: Any listed refusal condition encountered</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a6-protected-zones-immutable-without-mutation","title":"A6 \u2014 Protected Zones Immutable Without Mutation","text":"<ul> <li>Action: REQUIRE_MUTATION</li> <li>Severity: CRITICAL</li> <li>Trigger: Any change affecting protected zones</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a7-mutation-is-the-only-legal-canon-change","title":"A7 \u2014 Mutation Is the Only Legal Canon Change","text":"<ul> <li>Action: REQUIRE_MUTATION</li> <li>Severity: CRITICAL</li> <li>Trigger: Any canon change proposed outside mutation workflow</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a8-no-shadow-architecture","title":"A8 \u2014 No Shadow Architecture","text":"<ul> <li>Action: HITL</li> <li>Severity: HIGH</li> <li>Trigger: Introduction of unauthorized structural patterns</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a9-determinism-is-required","title":"A9 \u2014 Determinism Is Required","text":"<ul> <li>Action: HITL</li> <li>Severity: HIGH</li> <li>Trigger: Output divergence risk or ambiguous authority</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#a10-hitl-break-glass-marker-mandatory","title":"A10 \u2014 HITL Break-Glass Marker Mandatory","text":"<ul> <li>Action: BLOCK</li> <li>Severity: CRITICAL</li> <li>Trigger: Agent continues execution after emitting marker</li> </ul>"},{"location":"canon/ENFORCEMENT_MATRIX/#4-security-model-enforcement","title":"4. Security Model Enforcement","text":"<p>Security boundary changes are always protected.</p> <ul> <li>Action: REQUIRE_MUTATION</li> <li>Severity: CRITICAL</li> <li>Trigger: Any security trust boundary assumption change</li> </ul> <p>If security model lacks evidence: - Action: HITL - Severity: CRITICAL - Trigger: Any attempt to draft boundaries without repo evidence</p>"},{"location":"canon/ENFORCEMENT_MATRIX/#5-compiler-enforcement-if-enabled","title":"5. Compiler Enforcement (If Enabled)","text":"<p>If compiler validation fails: - Action: BLOCK - Severity: CRITICAL - Trigger: Schema invalidity, precedence cycles, missing required fields</p> <p>No execution may proceed when compiler fails.</p> <p>This matrix defines how canon becomes enforceable behavior.</p>"},{"location":"canon/TERMINOLOGY/","title":"TERMINOLOGY","text":"<p>This file defines authoritative terms used by SAGT.</p> <p>The purpose is to prevent semantic drift.</p> <p>If a term is used in canon, it should be defined here.</p> <p>If two definitions conflict, precedence rules apply and execution must halt if unresolved.</p>"},{"location":"canon/TERMINOLOGY/#canon","title":"Canon","text":"<p>The highest authority layer in SAGT. Canon defines binding rules and enforcement semantics.</p>"},{"location":"canon/TERMINOLOGY/#precedence","title":"Precedence","text":"<p>The explicit ordering of canonical authority. Higher precedence overrides lower precedence. Unresolved conflicts require human validation.</p>"},{"location":"canon/TERMINOLOGY/#task-group","title":"Task Group","text":"<p>A strict intent classification category. Every request maps to exactly one task group.</p>"},{"location":"canon/TERMINOLOGY/#skill","title":"Skill","text":"<p>A deterministic procedure module. Skills execute known procedure and cannot introduce architecture.</p>"},{"location":"canon/TERMINOLOGY/#spec-first-workflow","title":"Spec-First Workflow","text":"<p>A workflow requiring requirements, design, and tasks artifacts before execution. Used to prevent architecture from emerging implicitly.</p>"},{"location":"canon/TERMINOLOGY/#protected-zone","title":"Protected Zone","text":"<p>A region of governance authority that cannot be modified without mutation. Typically includes invariants and security boundaries.</p>"},{"location":"canon/TERMINOLOGY/#mutation","title":"Mutation","text":"<p>The formal mechanism for changing canon. Includes proposal, impact analysis, validation, and version traceability.</p>"},{"location":"canon/TERMINOLOGY/#hitl-human-in-the-loop","title":"HITL (Human-in-the-Loop)","text":"<p>A mandatory stop requiring human validation. Signaled by the marker <code>[AWAIT_HUMAN_VALIDATION]</code>.</p>"},{"location":"canon/TERMINOLOGY/#shadow-architecture","title":"Shadow Architecture","text":"<p>Unauthorized structural patterns introduced without canonical authorization.</p>"},{"location":"canon/TERMINOLOGY/#determinism","title":"Determinism","text":"<p>Structural convergence under identical canon, spec, and inputs.</p>"},{"location":"canon/TERMINOLOGY/#policy-engine","title":"Policy Engine","text":"<p>A monitoring layer that observes systemic drift patterns. It escalates; it does not override canon.</p>"},{"location":"canon/TERMINOLOGY/#canon-compiler","title":"Canon Compiler","text":"<p>A validator that extracts structured rules and detects conflicts, cycles, and invalidity.</p> <p>This terminology file is authoritative for SAGT vocabulary.</p>"},{"location":"canon/compiler/","title":"Canon Compiler","text":"<p>The Canon Compiler formalizes governance rules into structured, machine-validated authority.</p> <p>Prose explains intent. Structured rule blocks encode enforcement.</p> <p>The compiler extracts, validates, and analyzes these rule blocks to ensure canonical integrity.</p> <p>Without formal validation, canon risks becoming descriptive rather than enforceable.</p>"},{"location":"canon/compiler/#why-a-compiler-is-necessary","title":"Why a Compiler Is Necessary","text":"<p>Text alone is insufficient for deterministic governance.</p> <p>Prose can:</p> <ul> <li>Contain ambiguity.</li> <li>Hide contradictions.</li> <li>Imply precedence without declaring it.</li> <li>Introduce silent overrides.</li> <li>Leave enforcement undefined.</li> </ul> <p>The compiler prevents governance drift by making rule structure explicit.</p> <p>It enforces structural correctness before execution begins.</p>"},{"location":"canon/compiler/#structured-rule-blocks","title":"Structured Rule Blocks","text":"<p>Canon may include structured rule definitions, for example:</p> <p>```yaml rule_id: I2 category: invariant scope: execution precedence: high type: requirement severity: critical protected_zone: true enforcement:   on_violation: refuse</p>"},{"location":"canon/mutation/","title":"Canon Mutation","text":"<p>Canon Mutation is the formal process by which canonical authority may change.</p> <p>It is the only legal mechanism for modifying:</p> <ul> <li>Invariants</li> <li>Precedence rules</li> <li>Protected Zones</li> <li>Enforcement semantics</li> <li>Governance boundaries</li> </ul> <p>All other modification attempts must halt execution.</p> <p>Mutation is rare by design.</p>"},{"location":"canon/mutation/#why-mutation-must-be-formal","title":"Why Mutation Must Be Formal","text":"<p>AI systems naturally adapt.</p> <p>Without structured mutation:</p> <ul> <li>Architecture shifts silently.</li> <li>Precedence rules erode.</li> <li>Enforcement becomes inconsistent.</li> <li>Historical determinism is lost.</li> </ul> <p>Formal mutation prevents incremental drift.</p> <p>It forces visibility before change.</p>"},{"location":"canon/mutation/#when-mutation-is-required","title":"When Mutation Is Required","text":"<p>Mutation is required if:</p> <ul> <li>A Protected Zone is modified.</li> <li>A new invariant is introduced.</li> <li>Enforcement behavior changes.</li> <li>Precedence ordering changes.</li> <li>A shadow pattern must be legitimized.</li> <li>Compiler schema evolves.</li> <li>Governance boundaries shift.</li> </ul> <p>If change impacts structural authority, mutation is mandatory.</p>"},{"location":"canon/mutation/#mutation-workflow","title":"Mutation Workflow","text":"<p>A Canon Mutation must include:</p> <ol> <li>Mutation Proposal  </li> <li>Description of change  </li> <li>Scope of impact  </li> <li> <p>Justification  </p> </li> <li> <p>Impact Analysis  </p> </li> <li>Affected rules  </li> <li>Affected enforcement behaviors  </li> <li>Downstream governance implications  </li> <li> <p>Determinism impact  </p> </li> <li> <p>Compatibility Review  </p> </li> <li>Backward compatibility status  </li> <li> <p>Migration path (if required)  </p> </li> <li> <p>Version Increment  </p> </li> <li>Canon version bump  </li> <li> <p>Change log entry  </p> </li> <li> <p>Human Validation  </p> </li> </ol> <p>Without all five, mutation is invalid.</p>"},{"location":"canon/mutation/#mutation-refusal-conditions","title":"Mutation Refusal Conditions","text":"<p>Mutation must be rejected if:</p> <ul> <li>It introduces ambiguity.</li> <li>It reduces enforcement clarity.</li> <li>It weakens invariant protection.</li> <li>It collapses separation of concerns.</li> <li>It bypasses protected zones indirectly.</li> <li>It creates circular precedence overrides.</li> </ul> <p>Mutation must improve clarity, not reduce it.</p>"},{"location":"canon/mutation/#mutation-and-versioning","title":"Mutation and Versioning","text":"<p>Canon versioning is mandatory.</p> <p>Every mutation increments version.</p> <p>Execution logs must record:</p> <ul> <li>Canon version</li> <li>Mutation ID (if applicable)</li> </ul> <p>This enables:</p> <ul> <li>Reproducibility</li> <li>Historical audit</li> <li>Multi-model stability</li> <li>Rollback capability</li> </ul> <p>Unversioned mutation destroys determinism.</p>"},{"location":"canon/mutation/#mutation-and-shadow-patterns","title":"Mutation and Shadow Patterns","text":"<p>Shadow patterns occur when agents introduce architectural behavior not explicitly authorized by canon.</p> <p>When detected, the agent must choose:</p> <p>A) Remove the pattern B) Initiate mutation  </p> <p>Mutation formalizes the pattern.</p> <p>Silent adoption is prohibited.</p>"},{"location":"canon/mutation/#mutation-granularity","title":"Mutation Granularity","text":"<p>Mutation should be:</p> <ul> <li>Minimal</li> <li>Explicit</li> <li>Isolated</li> </ul> <p>Broad mutation increases systemic risk.</p> <p>Small, well-scoped mutation preserves stability.</p>"},{"location":"canon/mutation/#mutation-and-policy","title":"Mutation and Policy","text":"<p>Policy Engine monitors mutation frequency.</p> <p>Excessive mutation may indicate:</p> <ul> <li>Canon incompleteness</li> <li>Overly rigid governance</li> <li>Poor initial rule modeling</li> </ul> <p>Policy does not prevent mutation. It surfaces systemic instability.</p>"},{"location":"canon/mutation/#mutation-failure-modes","title":"Mutation Failure Modes","text":"<p>Improper mutation leads to:</p> <ul> <li>Inconsistent enforcement</li> <li>Canon contradiction</li> <li>Protected Zone weakening</li> <li>Drift disguised as evolution</li> </ul> <p>Mutation must strengthen clarity.</p> <p>If clarity decreases, mutation must be rejected.</p> <p>Canon Mutation is the evolution valve of SAGT.</p> <p>It ensures that governance can adapt without sacrificing determinism or integrity.</p>"},{"location":"canon/protected-zones/","title":"Protected Zones","text":"<p>Protected Zones are high-authority regions of the governance model.</p> <p>They define structural elements that must not change implicitly.</p> <p>Protected Zones exist to prevent architectural drift in areas where silent modification would compromise system integrity.</p> <p>They are not advisory. They are structurally guarded.</p>"},{"location":"canon/protected-zones/#why-protected-zones-exist","title":"Why Protected Zones Exist","text":"<p>Without protected zones, small incremental changes accumulate into structural instability.</p> <p>For example:</p> <ul> <li>A skill subtly modifies error handling behavior.</li> <li>A security boundary is reinterpreted.</li> <li>Canon precedence is reordered.</li> <li>Task group exclusivity is relaxed.</li> </ul> <p>Each change may appear small.</p> <p>Over time, invariants erode.</p> <p>Protected Zones freeze these critical structures.</p> <p>They ensure that fundamental rules cannot be altered without explicit mutation.</p>"},{"location":"canon/protected-zones/#what-typically-constitutes-a-protected-zone","title":"What Typically Constitutes a Protected Zone","text":"<p>Protected Zones often include:</p> <ul> <li>Security boundaries and trust models</li> <li>Canon precedence order</li> <li>Invariant definitions</li> <li>Task group exclusivity model</li> <li>Skill authority boundaries</li> <li>Spec-first enforcement requirement</li> <li>Compiler schema structure</li> </ul> <p>These areas define how the system governs itself.</p> <p>They must remain stable unless formally mutated.</p>"},{"location":"canon/protected-zones/#enforcement-behavior","title":"Enforcement Behavior","text":"<p>Protected Zones cannot be modified by:</p> <ul> <li>Skills</li> <li>Implementation tasks</li> <li>Spec generation</li> <li>Automatic refactoring</li> </ul> <p>Attempted modification triggers:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>And requires a Canon Mutation workflow.</p> <p>No silent adjustment is permitted.</p>"},{"location":"canon/protected-zones/#mutation-requirements","title":"Mutation Requirements","text":"<p>To modify a Protected Zone:</p> <ol> <li>A Canon Mutation Spec must be created.</li> <li>Impact analysis must include:</li> <li>Downstream enforcement changes</li> <li>Policy metric impact</li> <li>Determinism implications</li> <li>Human validation must occur.</li> <li>Canon version must increment.</li> </ol> <p>Protected Zones demand the highest scrutiny.</p>"},{"location":"canon/protected-zones/#failure-modes-without-protected-zones","title":"Failure Modes Without Protected Zones","text":"<p>If Protected Zones do not exist:</p> <ul> <li>Security boundaries drift under optimization.</li> <li>Skills expand beyond procedural authority.</li> <li>Canon becomes descriptive instead of enforceable.</li> <li>Spec-first discipline collapses.</li> <li>Governance becomes optional.</li> </ul> <p>The system gradually reverts to implicit authority.</p> <p>Protected Zones prevent regression into informal governance.</p>"},{"location":"canon/protected-zones/#scope-clarity","title":"Scope Clarity","text":"<p>Each Protected Zone must declare:</p> <ul> <li>Scope (what is protected)</li> <li>Authority level</li> <li>Mutation requirement</li> <li>Enforcement behavior</li> </ul> <p>Ambiguous Protected Zones are dangerous.</p> <p>Ambiguity produces selective interpretation.</p> <p>Selective interpretation produces shadow authority.</p>"},{"location":"canon/protected-zones/#example-scenario","title":"Example Scenario","text":"<p>Suppose an agent proposes introducing a new error-handling pattern across the system.</p> <p>If error-handling model is inside a Protected Zone:</p> <p>The agent must:</p> <ul> <li>Halt execution.</li> <li>Generate a Canon Mutation Spec.</li> <li>Request validation.</li> </ul> <p>If it proceeds without mutation, governance is broken.</p>"},{"location":"canon/protected-zones/#protected-zones-and-determinism","title":"Protected Zones and Determinism","text":"<p>Protected Zones support determinism by stabilizing structural behavior.</p> <p>If structural rules change silently, identical specs may produce different outputs over time.</p> <p>Versioned mutation preserves reproducibility.</p>"},{"location":"canon/protected-zones/#interaction-with-policy-engine","title":"Interaction with Policy Engine","text":"<p>Policy monitors attempts to modify Protected Zones.</p> <p>Repeated attempts may signal:</p> <ul> <li>Canon gaps</li> <li>Overly rigid constraints</li> <li>Architectural pressure</li> </ul> <p>Policy does not override Protected Zones. It signals systemic stress.</p> <p>Protected Zones define the immovable core of SAGT.</p> <p>They exist not to prevent evolution, but to ensure that evolution is deliberate.</p>"},{"location":"canon/rule-schema-v2/","title":"Rule Schema v2","text":"<p>Rule Schema v2 defines the formal structure for encoding canonical rules in machine-validated form.</p> <p>It replaces implicit narrative authority with explicit structural semantics.</p> <p>The schema enables:</p> <ul> <li>Deterministic precedence resolution</li> <li>Dependency tracking</li> <li>Override clarity</li> <li>Protected zone enforcement</li> <li>Compiler validation</li> <li>Enforcement matrix generation</li> </ul> <p>Without a formal schema, canon remains partially interpretive.</p>"},{"location":"canon/rule-schema-v2/#design-goals","title":"Design Goals","text":"<p>Rule Schema v2 must:</p> <ol> <li>Eliminate implicit authority.</li> <li>Encode precedence explicitly.</li> <li>Support dependency relationships.</li> <li>Support override declarations.</li> <li>Encode enforcement semantics.</li> <li>Support protected zone tagging.</li> <li>Remain human-readable.</li> <li>Be compiler-validatable.</li> </ol> <p>The schema must favor clarity over brevity.</p>"},{"location":"canon/rule-schema-v2/#required-rule-fields","title":"Required Rule Fields","text":"<p>Each rule block must declare:</p> <ul> <li>rule_id (unique identifier)</li> <li>version (optional but recommended)</li> <li>category</li> <li>scope</li> <li>type</li> <li>precedence</li> <li>enforcement</li> <li>protected_zone (boolean)</li> <li>dependencies (optional)</li> <li>overrides (optional)</li> </ul> <p>Incomplete rules are invalid.</p>"},{"location":"canon/rule-schema-v2/#canonical-rule-block-example","title":"Canonical Rule Block Example","text":"<p>```yaml rule_id: I2 version: 1 category: invariant scope: execution type: requirement precedence: high protected_zone: true dependencies: [] overrides: [] enforcement:   on_violation: refuse   escalation: hitl   severity: critical</p>"},{"location":"canon/security-model/","title":"Security Model","text":"<p>The Security Model defines trust boundaries, authority assumptions, and enforcement expectations within SAGT.</p> <p>Security is not implied. It must be declared.</p> <p>SAGT treats undefined security assumptions as structural instability.</p> <p>Execution must halt if security boundaries are unclear.</p>"},{"location":"canon/security-model/#why-a-security-model-is-required","title":"Why a Security Model Is Required","text":"<p>AI agents are capable of:</p> <ul> <li>Modifying access boundaries.</li> <li>Introducing new data flows.</li> <li>Changing execution contexts.</li> <li>Expanding privilege implicitly.</li> </ul> <p>Without a declared security model:</p> <ul> <li>Trust assumptions drift.</li> <li>Sensitive boundaries erode.</li> <li>Mutation may introduce unintended exposure.</li> <li>Determinism degrades under privilege ambiguity.</li> </ul> <p>Security must be canonical.</p>"},{"location":"canon/security-model/#core-security-principles","title":"Core Security Principles","text":"<ol> <li>All trust boundaries must be explicit.</li> <li>All privilege assumptions must be declared.</li> <li>All external interfaces must be scoped.</li> <li>Protected zones include security-critical invariants.</li> <li>Security modifications require mutation.</li> </ol> <p>Security ambiguity is not tolerated.</p>"},{"location":"canon/security-model/#trust-boundary-declaration","title":"Trust Boundary Declaration","text":"<p>Trust boundaries must declare:</p> <ul> <li>Actor types</li> <li>Execution context</li> <li>Privilege scope</li> <li>Data ownership</li> <li>Mutation authority</li> </ul> <p>Example boundary categories:</p> <ul> <li>Human operator</li> <li>Agent</li> <li>Compiler</li> <li>Policy Engine</li> <li>External system</li> <li>Deployment environment</li> </ul> <p>Boundaries must not be inferred.</p>"},{"location":"canon/security-model/#security-and-task-groups","title":"Security and Task Groups","text":"<p>Certain Task Groups inherently carry elevated security risk:</p> <ul> <li>Canon Mutation</li> <li>Compiler schema modification</li> <li>Policy threshold adjustment</li> <li>Security boundary change</li> <li>External system integration</li> </ul> <p>These Task Groups require:</p> <ul> <li>Explicit Spec-first workflow</li> <li>Mandatory HITL</li> <li>Protected zone enforcement</li> </ul> <p>Security-sensitive execution cannot be trivial.</p>"},{"location":"canon/security-model/#security-and-protected-zones","title":"Security and Protected Zones","text":"<p>Security invariants must be marked as protected_zone: true.</p> <p>Examples:</p> <ul> <li>Authentication model</li> <li>Authorization hierarchy</li> <li>Role definitions</li> <li>Data classification boundaries</li> <li>External API permission model</li> </ul> <p>Protected security rules may not be overridden without mutation.</p>"},{"location":"canon/security-model/#security-and-mutation","title":"Security and Mutation","text":"<p>Security-related mutation must include:</p> <ul> <li>Threat surface analysis</li> <li>Privilege escalation analysis</li> <li>Backward compatibility review</li> <li>Audit impact review</li> <li>Policy threshold adjustment (if required)</li> </ul> <p>Mutation that alters security assumptions requires highest scrutiny.</p>"},{"location":"canon/security-model/#undefined-security-assumptions","title":"Undefined Security Assumptions","text":"<p>If the agent encounters:</p> <ul> <li>Undefined trust boundaries</li> <li>Unspecified access control model</li> <li>Ambiguous privilege scope</li> <li>Incomplete security documentation</li> </ul> <p>The agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>No best-guess security behavior is allowed.</p>"},{"location":"canon/security-model/#security-telemetry","title":"Security Telemetry","text":"<p>Policy Engine may track:</p> <ul> <li>Frequency of security-related mutation</li> <li>Frequency of protected security zone touches</li> <li>Escalations triggered by boundary changes</li> <li>Spec bypass attempts on security tasks</li> </ul> <p>High frequency signals instability.</p>"},{"location":"canon/security-model/#security-and-determinism","title":"Security and Determinism","text":"<p>Security assumptions influence determinism.</p> <p>If privilege scope varies between executions:</p> <ul> <li>Outputs may differ.</li> <li>Enforcement behavior may change.</li> <li>Structural equivalence collapses.</li> </ul> <p>Security boundaries must be stable and versioned.</p>"},{"location":"canon/security-model/#security-and-multi-model-execution","title":"Security and Multi-Model Execution","text":"<p>Different models must:</p> <ul> <li>Respect identical security boundaries.</li> <li>Not reinterpret privilege scope.</li> <li>Not expand enforcement behavior.</li> </ul> <p>Security behavior must not depend on model personality.</p>"},{"location":"canon/security-model/#security-failure-modes","title":"Security Failure Modes","text":"<p>Security degradation occurs when:</p> <ul> <li>Trust boundaries are implicit.</li> <li>Protected zones are unmarked.</li> <li>Mutation bypasses security review.</li> <li>Task Groups collapse authority.</li> </ul>"},{"location":"governance/handover/","title":"Handover Protocol","text":"<p>The Handover Protocol preserves governance continuity across time, sessions, and model changes.</p> <p>AI agents do not retain state reliably. Context windows reset. Models change. Sessions expire.</p> <p>Governance must survive these boundaries.</p> <p>The Handover Protocol externalizes execution state into structured artifacts.</p>"},{"location":"governance/handover/#why-handover-exists","title":"Why Handover Exists","text":"<p>Without structured handover:</p> <ul> <li>Execution resumes from partial memory.</li> <li>Canon version mismatches occur.</li> <li>Spec intent is lost.</li> <li>Task Group context is forgotten.</li> <li>Policy state is reset.</li> <li>Drift accelerates.</li> </ul> <p>Implicit continuity is unsafe.</p> <p>Handover makes continuity explicit.</p>"},{"location":"governance/handover/#the-handovermd-artifact","title":"The HANDOVER.md Artifact","text":"<p>If execution is incomplete, the agent must update:</p> <p>.jtasks/HANDOVER.md</p> <p>This file captures the \u201cgovernance state\u201d of execution.</p> <p>It is not narrative. It is structured operational state.</p>"},{"location":"governance/handover/#required-handover-fields","title":"Required Handover Fields","text":"<p>HANDOVER.md must include:</p> <ul> <li>Current Task Group</li> <li>Canon version</li> <li>Active spec status</li> <li>Pending tasks</li> <li>Completed tasks</li> <li>Last refusal trigger (if any)</li> <li>Last HITL trigger (if any)</li> <li>Policy state snapshot</li> <li>Known structural risks</li> <li>Open mutation proposals (if any)</li> </ul> <p>Handover must be factual and minimal.</p> <p>It must not speculate.</p>"},{"location":"governance/handover/#when-handover-is-required","title":"When Handover Is Required","text":"<p>Handover must be updated when:</p> <ul> <li>Spec execution is incomplete.</li> <li>HITL is triggered.</li> <li>Mutation is proposed but not finalized.</li> <li>Task execution pauses mid-sequence.</li> <li>Model switching is expected.</li> <li>Context window reset is imminent.</li> </ul> <p>If the spec is complete and no governance state remains active, handover is optional.</p>"},{"location":"governance/handover/#multi-model-continuity","title":"Multi-Model Continuity","text":"<p>SAGT is model-agnostic.</p> <p>One model may:</p> <ul> <li>Begin spec.</li> <li>Trigger mutation.</li> <li>Halt at HITL.</li> </ul> <p>Another model may resume.</p> <p>The new model must:</p> <ol> <li>Read canon.</li> <li>Read spec.</li> <li>Read HANDOVER.md.</li> <li>Validate consistency.</li> <li>Continue execution deterministically.</li> </ol> <p>Governance must not depend on prior reasoning memory.</p>"},{"location":"governance/handover/#handover-and-determinism","title":"Handover and Determinism","text":"<p>Determinism requires externalized reasoning.</p> <p>Without handover:</p> <ul> <li>Implicit assumptions creep in.</li> <li>Task ordering may shift.</li> <li>Mutation context may be lost.</li> </ul> <p>Handover externalizes state so reasoning becomes reproducible.</p>"},{"location":"governance/handover/#handover-failure-modes","title":"Handover Failure Modes","text":"<p>If HANDOVER.md is incomplete:</p> <ul> <li>Task Group context may be misapplied.</li> <li>Canon version mismatch may occur.</li> <li>Mutation may proceed incorrectly.</li> <li>Policy evaluation may be inaccurate.</li> </ul> <p>Incomplete handover is a governance risk.</p>"},{"location":"governance/handover/#handover-and-policy","title":"Handover and Policy","text":"<p>Policy may evaluate:</p> <ul> <li>Frequency of incomplete executions.</li> <li>Repeated stalls.</li> <li>Frequent HITL triggers.</li> <li>Mutation bottlenecks.</li> </ul> <p>High handover churn may indicate structural instability.</p> <p>Handover logs provide observability.</p>"},{"location":"governance/handover/#handover-is-not-a-diary","title":"Handover Is Not a Diary","text":"<p>HANDOVER.md must not contain:</p> <ul> <li>Speculative reasoning.</li> <li>Internal chain-of-thought.</li> <li>Emotional language.</li> <li>Design re-interpretation.</li> </ul> <p>It must contain:</p> <ul> <li>Declarative state.</li> <li>Clear next action.</li> <li>Governance boundaries.</li> </ul>"},{"location":"governance/handover/#handover-and-mutation","title":"Handover and Mutation","text":"<p>If mutation is pending:</p> <p>HANDOVER.md must include:</p> <ul> <li>Mutation ID</li> <li>Canon version target</li> <li>Approval status</li> <li>Impact summary</li> </ul> <p>Mutation without clear handover state risks governance inconsistency.</p>"},{"location":"governance/handover/#handover-integrity-rule","title":"Handover Integrity Rule","text":"<p>Execution must not resume until:</p> <ul> <li>HANDOVER.md is validated.</li> <li>Canon version matches.</li> <li>Spec state is consistent.</li> <li>Task Group is confirmed.</li> </ul> <p>If inconsistency exists:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>The Handover Protocol ensures that governance survives interruption.</p> <p>It converts fragile conversational memory into</p>"},{"location":"governance/hitl/","title":"Human-in-the-Loop (HITL)","text":"<p>Human-in-the-Loop (HITL) is the escalation boundary of SAGT.</p> <p>It defines when automated execution must stop and authority must transfer to a human decision-maker.</p> <p>HITL is not optional. It is a structural enforcement mechanism.</p> <p>When governance uncertainty exceeds defined limits, automation halts.</p>"},{"location":"governance/hitl/#the-break-glass-marker","title":"The Break-Glass Marker","text":"<p>When execution must pause, the agent emits:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>The marker must appear on its own line.</p> <p>After emitting it: - No further execution may continue. - No speculative continuation is permitted.</p> <p>The marker is machine-detectable. It enables IDE and CI tooling to pause execution automatically.</p>"},{"location":"governance/hitl/#why-hitl-exists","title":"Why HITL Exists","text":"<p>AI agents optimize for completion.</p> <p>They will attempt to:</p> <ul> <li>Resolve ambiguity.</li> <li>Choose the most plausible interpretation.</li> <li>Continue execution under uncertainty.</li> <li>Infer missing authority.</li> </ul> <p>SAGT forbids this.</p> <p>HITL exists to prevent automated reconciliation of incomplete governance.</p> <p>Stopping reveals structural gaps.</p>"},{"location":"governance/hitl/#mandatory-hitl-triggers","title":"Mandatory HITL Triggers","text":"<p>The agent must emit HITL when:</p> <ul> <li>Canon conflict cannot be resolved by precedence.</li> <li>Task Group classification is ambiguous.</li> <li>A Protected Zone is touched.</li> <li>Canon mutation is required.</li> <li>Enforcement semantics are undefined.</li> <li>Policy threshold is exceeded.</li> <li>Determinism cannot be guaranteed.</li> <li>Security boundaries are undefined or incomplete.</li> </ul> <p>These triggers are not advisory. They are mandatory.</p>"},{"location":"governance/hitl/#optional-hitl-triggers","title":"Optional HITL Triggers","text":"<p>Canon may define additional escalation rules, such as:</p> <ul> <li>High mutation frequency</li> <li>Excessive shadow pattern detection</li> <li>Repeated refusal loops</li> <li>TTL deprecation review events</li> </ul> <p>Optional triggers are defined by governance configuration.</p>"},{"location":"governance/hitl/#hitl-and-mutation","title":"HITL and Mutation","text":"<p>All Canon Mutation requires HITL.</p> <p>Mutation cannot be self-approved by the agent.</p> <p>Human validation is required to preserve accountability.</p> <p>Mutation without HITL breaks authority layering.</p>"},{"location":"governance/hitl/#hitl-and-task-reclassification","title":"HITL and Task Reclassification","text":"<p>If during execution a task crosses into a different Task Group:</p> <p>The agent must:</p> <ul> <li>Halt.</li> <li>Emit HITL.</li> <li>Request classification confirmation.</li> </ul> <p>Silent reclassification is forbidden.</p>"},{"location":"governance/hitl/#hitl-and-policy-engine","title":"HITL and Policy Engine","text":"<p>Policy may trigger HITL when thresholds are exceeded.</p> <p>Examples:</p> <ul> <li>Refusal rate exceeds defined window.</li> <li>Shadow patterns exceed acceptable frequency.</li> <li>Canon TTL flags require review.</li> </ul> <p>Policy does not override canon. It escalates systemic stress.</p>"},{"location":"governance/hitl/#hitl-failure-modes","title":"HITL Failure Modes","text":"<p>If HITL is ignored or bypassed:</p> <ul> <li>Canon authority erodes.</li> <li>Protected zones weaken.</li> <li>Determinism collapses.</li> <li>Governance becomes advisory.</li> <li>Drift accelerates.</li> </ul> <p>HITL is a structural stop, not a suggestion.</p>"},{"location":"governance/hitl/#human-responsibility","title":"Human Responsibility","text":"<p>HITL does not guarantee correctness.</p> <p>It guarantees conscious decision-making.</p> <p>When HITL is triggered, the human must:</p> <ul> <li>Resolve ambiguity.</li> <li>Approve or reject mutation.</li> <li>Clarify authority boundaries.</li> <li>Update canon if required.</li> </ul> <p>Human intervention must be deliberate, not reactive.</p>"},{"location":"governance/hitl/#hitl-and-determinism","title":"HITL and Determinism","text":"<p>HITL preserves determinism by externalizing ambiguity.</p> <p>Rather than resolving uncertainty implicitly, the system pauses and records the decision.</p> <p>This ensures:</p> <ul> <li>Decisions are traceable.</li> <li>Canon evolves explicitly.</li> <li>Multi-model execution</li> </ul>"},{"location":"governance/shadow-architecture/","title":"Shadow Architecture","text":"<p>Shadow Architecture is any structural behavior introduced by an agent that is not explicitly authorized by canon.</p> <p>It is one of the most common and most dangerous forms of governance erosion.</p> <p>Shadow Architecture rarely appears as an obvious violation. It appears as improvement.</p>"},{"location":"governance/shadow-architecture/#why-shadow-architecture-happens","title":"Why Shadow Architecture Happens","text":"<p>AI agents are trained on patterns.</p> <p>When solving problems, they will:</p> <ul> <li>Introduce abstractions seen in training data.</li> <li>Adopt familiar design patterns.</li> <li>Optimize structure locally.</li> <li>Improve readability using known paradigms.</li> <li>Generalize edge-case handling.</li> </ul> <p>These behaviors are rational.</p> <p>But they are not governed.</p> <p>If a pattern is not authorized by canon, it is shadow architecture.</p>"},{"location":"governance/shadow-architecture/#common-examples","title":"Common Examples","text":"<p>Shadow Architecture often appears as:</p> <ul> <li>Introducing a Result abstraction when canon defines explicit error handling. <li>Adding global state for convenience.</li> <li>Introducing dependency injection when not specified.</li> <li>Changing error propagation semantics.</li> <li>Introducing event buses or pub/sub models.</li> <li>Refactoring toward a framework pattern not declared in canon.</li> <li>Altering data ownership boundaries.</li> <li>Changing concurrency models implicitly.</li> <p>The pattern may be technically sound. That is not the issue.</p> <p>The issue is authorization.</p>"},{"location":"governance/shadow-architecture/#why-shadow-architecture-is-dangerous","title":"Why Shadow Architecture Is Dangerous","text":"<p>Shadow patterns:</p> <ul> <li>Alter invariants silently.</li> <li>Bypass mutation workflow.</li> <li>Undermine protected zones.</li> <li>Erode determinism.</li> <li>Create hidden precedence shifts.</li> <li>Fragment architectural coherence.</li> </ul> <p>Because shadow patterns often improve local clarity, they are easy to accept.</p> <p>Long-term, they degrade structural governance.</p>"},{"location":"governance/shadow-architecture/#detection-mechanisms","title":"Detection Mechanisms","text":"<p>Shadow Architecture may be detected through:</p> <ol> <li> <p>Canon citation gaps    If structural decisions lack canonical reference.</p> </li> <li> <p>Policy metrics    Elevated mutation pressure or repeated pattern introduction.</p> </li> <li> <p>Skill scope violations    Procedural tasks introducing architectural constructs.</p> </li> <li> <p>Compiler mismatch    Structured rule blocks do not reflect implementation behavior.</p> </li> <li> <p>Manual audit    \"Canon vs Reality\" comparison.</p> </li> </ol> <p>Detection must be explicit. Agents must not self-approve new structure.</p>"},{"location":"governance/shadow-architecture/#required-response","title":"Required Response","text":"<p>When Shadow Architecture is detected, the agent must choose:</p> <p>A) Revert to canonical behavior B) Initiate Canon Mutation</p> <p>Silent continuation is forbidden.</p> <p>The agent must not justify the change based on technical superiority. Authority, not elegance, determines legitimacy.</p>"},{"location":"governance/shadow-architecture/#shadow-vs-refactor","title":"Shadow vs Refactor","text":"<p>Not all structural changes are shadow architecture.</p> <p>A legitimate refactor:</p> <ul> <li>Preserves invariants.</li> <li>Does not alter enforcement semantics.</li> <li>Does not redefine authority boundaries.</li> <li>Remains within declared Task Group.</li> </ul> <p>A shadow pattern:</p> <ul> <li>Introduces new structural assumptions.</li> <li>Alters system behavior model.</li> <li>Expands skill authority.</li> <li>Changes architectural contracts.</li> </ul> <p>The difference is governance impact.</p>"},{"location":"governance/shadow-architecture/#shadow-pressure","title":"Shadow Pressure","text":"<p>Repeated shadow pattern attempts may indicate:</p> <ul> <li>Canon incompleteness.</li> <li>Overly restrictive governance.</li> <li>Legitimate architectural evolution need.</li> </ul> <p>In such cases, mutation may be appropriate.</p> <p>Shadow detection does not block evolution. It forces evolution to be deliberate.</p>"},{"location":"governance/shadow-architecture/#shadow-architecture-and-skills","title":"Shadow Architecture and Skills","text":"<p>Skills are the most common vector for shadow architecture.</p> <p>If a skill repeatedly encounters the need to introduce structure:</p> <ul> <li>The pattern likely belongs in canon.</li> <li>Mutation may be warranted.</li> </ul> <p>Skills must not expand authority silently.</p>"},{"location":"governance/shadow-architecture/#shadow-architecture-and-policy","title":"Shadow Architecture and Policy","text":"<p>Policy Engine monitors shadow frequency.</p> <p>If shadow events exceed threshold:</p> <ul> <li>HITL is triggered.</li> <li>Governance review is required.</li> </ul> <p>High shadow frequency signals structural tension.</p>"},{"location":"governance/shadow-architecture/#shadow-and-determinism","title":"Shadow and Determinism","text":"<p>Shadow patterns compromise determinism.</p> <p>Two executions of the same spec may diverge if structural assumptions shift over time.</p> <p>Mutation with version increment preserves reproducibility. Shadow adoption destroys it.</p> <p>Shadow Architecture is the silent erosion of governance.</p> <p>SAGT detects it. SAGT halts it. SAGT forces deliberate evolution.</p>"},{"location":"governance/skills/","title":"Skills","text":"<p>Skills are procedural execution units.</p> <p>They exist to perform deterministic, bounded operations within a defined authority scope.</p> <p>Skills do not define architecture. Skills do not modify canon. Skills do not reinterpret governance.</p> <p>They execute procedure, not judgment.</p>"},{"location":"governance/skills/#why-skills-exist","title":"Why Skills Exist","text":"<p>AI agents naturally generalize.</p> <p>Without structured procedural boundaries, they will:</p> <ul> <li>Redesign systems during implementation.</li> <li>Introduce new patterns while refactoring.</li> <li>Modify enforcement semantics while solving edge cases.</li> <li>Expand authority implicitly.</li> </ul> <p>Skills prevent this by:</p> <ul> <li>Encoding known procedures.</li> <li>Defining authority scope explicitly.</li> <li>Declaring refusal triggers.</li> <li>Declaring allowed outputs.</li> </ul> <p>Skills reduce generative freedom in favor of structural safety.</p>"},{"location":"governance/skills/#skill-invariants","title":"Skill Invariants","text":"<p>All skills must satisfy the following invariants:</p> <ol> <li>A skill must declare its Task Group.</li> <li>A skill must declare refusal triggers.</li> <li>A skill must not introduce new invariants.</li> <li>A skill must not modify canon.</li> <li>A skill must halt when design judgment is required.</li> <li>A skill must be deterministic.</li> </ol> <p>If any invariant is violated, the skill is invalid.</p>"},{"location":"governance/skills/#skill-authority-boundaries","title":"Skill Authority Boundaries","text":"<p>Skills are authorized to:</p> <ul> <li>Execute repeatable mechanical operations.</li> <li>Generate artifacts specified by canon.</li> <li>Transform structured inputs into structured outputs.</li> <li>Apply predefined patterns.</li> </ul> <p>Skills are not authorized to:</p> <ul> <li>Redefine architecture.</li> <li>Create new governance rules.</li> <li>Modify protected zones.</li> <li>Change enforcement semantics.</li> <li>Resolve canon ambiguity.</li> <li>Override policy thresholds.</li> </ul> <p>Authority must be explicitly declared. If it is not declared, it is forbidden.</p>"},{"location":"governance/skills/#skill-and-task-group-relationship","title":"Skill and Task Group Relationship","text":"<p>Each skill belongs to exactly one Task Group.</p> <p>Skills may only execute within that Task Group.</p> <p>If execution crosses into another Task Group:</p> <ul> <li>The skill must halt.</li> <li>Reclassification must occur.</li> <li>Human validation may be required.</li> </ul> <p>Skills do not dynamically reclassify themselves.</p>"},{"location":"governance/skills/#skill-refusal-triggers","title":"Skill Refusal Triggers","text":"<p>Skills must define explicit refusal triggers.</p> <p>Examples:</p> <ul> <li>Canon conflict detected.</li> <li>Protected zone modification required.</li> <li>Undefined enforcement behavior encountered.</li> <li>Task group mismatch.</li> <li>Mutation required.</li> <li>Policy escalation triggered.</li> </ul> <p>When triggered, the skill halts immediately.</p>"},{"location":"governance/skills/#skill-and-shadow-architecture","title":"Skill and Shadow Architecture","text":"<p>Shadow architecture occurs when a skill introduces structural behavior not authorized by canon.</p> <p>Examples:</p> <ul> <li>Introducing a new result-handling abstraction.</li> <li>Adding global state implicitly.</li> <li>Changing error propagation model.</li> <li>Introducing new dependency patterns.</li> </ul> <p>When detected:</p> <p>The skill must either: A) Revert to canonical behavior. B) Halt and initiate mutation workflow.</p> <p>Silent adoption is forbidden.</p>"},{"location":"governance/skills/#skill-determinism","title":"Skill Determinism","text":"<p>Skills must produce equivalent output given equivalent inputs and canon state.</p> <p>Non-deterministic output indicates:</p> <ul> <li>Hidden assumptions.</li> <li>Implicit authority.</li> <li>Undefined rule dependency.</li> <li>Over-generalization.</li> </ul> <p>Non-deterministic skills must be refactored or rejected.</p>"},{"location":"governance/skills/#skill-failure-modes","title":"Skill Failure Modes","text":"<p>Improperly governed skills lead to:</p> <ul> <li>Architectural creep.</li> <li>Canon erosion.</li> <li>Security boundary drift.</li> <li>Task group collapse.</li> <li>Mutation bypass.</li> <li>Governance inconsistency.</li> </ul> <p>Skills are the most common drift vector. They must be tightly constrained.</p>"},{"location":"governance/skills/#skill-evolution","title":"Skill Evolution","text":"<p>Skills may evolve.</p> <p>However:</p> <ul> <li>Changes must remain within declared Task Group.</li> <li>Authority expansion requires canon mutation.</li> <li>Refusal triggers must remain explicit.</li> <li>Determinism must be preserved.</li> </ul> <p>Skill growth must not become architecture growth.</p>"},{"location":"governance/skills/#why-skills-are-not-decision-makers","title":"Why Skills Are Not Decision-Makers","text":"<p>Agents reason broadly. Skills execute narrowly.</p> <p>If skills are allowed to interpret ambiguous law:</p> <ul> <li>Governance collapses.</li> <li>Determinism degrades.</li> <li>Mutation becomes invisible.</li> </ul> <p>Skills stop at ambiguity. Human validation resolves it.</p> <p>Skills are bounded execution modules.</p> <p>They protect the system from procedural overreach.</p>"},{"location":"governance/spec-workflow/","title":"Spec-First Workflow","text":"<p>Spec-First Workflow is the temporal governance layer of SAGT.</p> <p>It prevents architecture from emerging implicitly during execution.</p> <p>Spec-First separates planning from doing.</p> <p>Execution must not define structure. Structure must be defined before execution begins.</p>"},{"location":"governance/spec-workflow/#why-spec-first-exists","title":"Why Spec-First Exists","text":"<p>AI agents naturally collapse planning and implementation.</p> <p>They will: - Design while coding. - Adjust invariants mid-execution. - Introduce new abstractions reactively. - Solve architectural gaps implicitly.</p> <p>Without temporal separation, architecture becomes accidental.</p> <p>Spec-First enforces order.</p>"},{"location":"governance/spec-workflow/#when-spec-is-required","title":"When Spec Is Required","text":"<p>Spec is required for non-trivial work.</p> <p>Non-trivial work typically includes:</p> <ul> <li>Architectural changes</li> <li>Structural refactors</li> <li>Cross-module modifications</li> <li>Security boundary changes</li> <li>Canon mutation</li> <li>Introduction of new system patterns</li> <li>Complex feature additions</li> </ul> <p>Trivial work may bypass Spec only if canon explicitly allows it.</p> <p>Spec requirement must be derived from canon, not inferred by the agent.</p>"},{"location":"governance/spec-workflow/#required-spec-artifacts","title":"Required Spec Artifacts","text":"<p>Spec consists of three ordered documents:</p> <ol> <li>requirements.md  </li> <li>design.md  </li> <li>tasks.md  </li> </ol> <p>Execution may begin only after these are complete and approved.</p> <p>Each artifact has a specific purpose.</p>"},{"location":"governance/spec-workflow/#requirementsmd","title":"requirements.md","text":"<p>Defines:</p> <ul> <li>The problem being solved</li> <li>The desired outcome</li> <li>Explicit constraints</li> <li>Non-goals</li> <li>Acceptance criteria</li> </ul> <p>Requirements define intent, not implementation.</p> <p>If requirements introduce architectural change, that must be stated explicitly.</p> <p>Ambiguous requirements halt progression to design.</p>"},{"location":"governance/spec-workflow/#designmd","title":"design.md","text":"<p>Defines:</p> <ul> <li>Structural decisions</li> <li>Data flow changes</li> <li>Interface changes</li> <li>Dependency impact</li> <li>Enforcement implications</li> <li>Policy implications</li> <li>Mutation requirement (if applicable)</li> </ul> <p>Design must reference canon explicitly.</p> <p>If design conflicts with canon, mutation must occur before execution.</p>"},{"location":"governance/spec-workflow/#tasksmd","title":"tasks.md","text":"<p>Defines:</p> <ul> <li>Ordered, executable steps</li> <li>Associated Task Group</li> <li>Associated Skill (if any)</li> <li>Expected output artifact</li> <li>Explicit refusal triggers (if relevant)</li> </ul> <p>Tasks must be atomic.</p> <p>Tasks must not redefine architecture.</p> <p>Tasks must not introduce new invariants.</p>"},{"location":"governance/spec-workflow/#approval-gate","title":"Approval Gate","text":"<p>Before execution begins:</p> <p>The agent must await approval.</p> <p>If required, emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Execution without approval violates temporal governance.</p> <p>Spec-First is meaningless without enforcement.</p>"},{"location":"governance/spec-workflow/#spec-drift-prevention","title":"Spec Drift Prevention","text":"<p>Once execution begins:</p> <ul> <li>Tasks may not redefine requirements.</li> <li>Tasks may not alter design structure.</li> <li>New architectural needs require halting and revisiting spec.</li> </ul> <p>Spec cannot evolve silently during execution.</p> <p>Drift is prevented by freezing design before action.</p>"},{"location":"governance/spec-workflow/#spec-and-determinism","title":"Spec and Determinism","text":"<p>Spec ensures reproducibility.</p> <p>Given: - Same canon - Same approved spec - Same input</p>"},{"location":"governance/task-groups/","title":"Task Groups","text":"<p>Task Groups define execution intent.</p> <p>Every request processed under SAGT must belong to exactly one Task Group.</p> <p>Task Groups exist to prevent the collapse of architectural authority into implementation behavior.</p> <p>They enforce separation of concerns at the intent level.</p>"},{"location":"governance/task-groups/#why-task-groups-exist","title":"Why Task Groups Exist","text":"<p>AI agents naturally merge responsibilities.</p> <p>They will: - Redesign architecture while implementing features. - Adjust invariants while refactoring code. - Modify governance while debugging behavior.</p> <p>Without strict classification, authority boundaries dissolve.</p> <p>Task Groups force intent clarity before execution.</p> <p>Intent determines allowed authority.</p>"},{"location":"governance/task-groups/#core-invariant","title":"Core Invariant","text":"<p>Each execution must map to exactly one Task Group.</p> <p>If classification is ambiguous: Execution halts.</p> <p>Mixed classification is prohibited because it collapses structural boundaries.</p>"},{"location":"governance/task-groups/#common-task-group-categories","title":"Common Task Group Categories","text":"<p>While implementation may vary, typical Task Groups include:</p> <ul> <li>Architecture</li> <li>Implementation</li> <li>Governance Maintenance</li> <li>Canon Maintenance</li> <li>Policy Evaluation</li> <li>Documentation (non-canonical)</li> <li>Spec Generation</li> </ul> <p>Each Task Group defines a distinct authority scope.</p>"},{"location":"governance/task-groups/#authority-boundaries","title":"Authority Boundaries","text":"<p>Task Groups determine what is allowed during execution.</p> <p>For example:</p> <p>Implementation Task Group: - May modify application logic. - May not modify canon. - May not alter protected zones.</p> <p>Architecture Task Group: - May propose structural changes. - May not execute implementation. - Must generate specification artifacts.</p> <p>Canon Maintenance Task Group: - May initiate mutation workflow. - May not perform application implementation.</p> <p>Authority is not shared across Task Groups.</p>"},{"location":"governance/task-groups/#task-group-misclassification","title":"Task Group Misclassification","text":"<p>Misclassification is one of the most dangerous failure modes.</p> <p>If an implementation request is classified as architecture:</p> <ul> <li>Spec may be bypassed.</li> <li>Protected zones may be indirectly touched.</li> <li>Governance may be weakened.</li> </ul> <p>If an architectural change is classified as implementation:</p> <ul> <li>Invariants may be modified implicitly.</li> <li>Mutation may be bypassed.</li> </ul> <p>Therefore classification must occur before any action.</p>"},{"location":"governance/task-groups/#enforcement-behavior","title":"Enforcement Behavior","text":"<p>When classification is ambiguous:</p> <p>The agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>It must not attempt best-guess categorization.</p> <p>Automatic reconciliation is forbidden.</p>"},{"location":"governance/task-groups/#task-group-and-spec-interaction","title":"Task Group and Spec Interaction","text":"<p>Some Task Groups require Spec-first enforcement.</p> <p>Examples:</p> <ul> <li>Architecture changes</li> <li>Canon mutation</li> <li>Large-scale refactors</li> <li>Security boundary changes</li> </ul> <p>Implementation tasks may bypass spec only if canon explicitly allows trivial execution.</p> <p>Spec requirement must be derived from canon, not inferred by the agent.</p>"},{"location":"governance/task-groups/#task-group-escalation","title":"Task Group Escalation","text":"<p>If during execution a request crosses boundaries:</p> <p>Example: An implementation task reveals architectural deficiency.</p> <p>The agent must:</p> <ul> <li>Halt.</li> <li>Reclassify.</li> <li>Possibly initiate mutation or architecture spec.</li> </ul> <p>It must not continue under the original classification.</p>"},{"location":"governance/task-groups/#task-groups-and-determinism","title":"Task Groups and Determinism","text":"<p>Strict Task Group isolation ensures:</p> <ul> <li>Reproducible execution patterns.</li> <li>Clear authority logs.</li> <li>Predictable governance enforcement.</li> <li>Reduced cross-domain leakage.</li> </ul> <p>Without strict classification, determinism degrades.</p>"},{"location":"governance/task-groups/#failure-modes-without-task-groups","title":"Failure Modes Without Task Groups","text":"<p>If Task Groups are relaxed:</p> <ul> <li>Architecture bleeds into implementation.</li> <li>Governance changes occur during debugging.</li> <li>Mutation is bypassed.</li> <li>Specs are skipped.</li> <li>Policy enforcement weakens.</li> </ul> <p>Task Groups are the intent firewall of SAGT.</p> <p>They prevent authority collapse at the earliest stage of execution.</p>"},{"location":"operations/adoption-guide/","title":"Governance Adoption Guide","text":"<p>SAGT is not a feature.</p> <p>It is an operating model.</p> <p>Adoption must be deliberate.</p> <p>This guide explains how teams transition from informal AI usage to governed AI-assisted development under SAGT.</p>"},{"location":"operations/adoption-guide/#why-adoption-requires-structure","title":"Why Adoption Requires Structure","text":"<p>Most teams already use AI.</p> <p>However, common patterns include:</p> <ul> <li>Prompt-based iteration without traceability</li> <li>Architecture defined reactively</li> <li>Silent pattern drift</li> <li>Informal code generation</li> <li>Untracked structural changes</li> </ul> <p>SAGT introduces discipline.</p> <p>Adoption is less about adding rules and more about formalizing authority.</p>"},{"location":"operations/adoption-guide/#adoption-phases","title":"Adoption Phases","text":"<p>Adoption should occur in phases.</p> <p>Immediate full enforcement often causes friction.</p> <p>Phased rollout allows governance to stabilize.</p>"},{"location":"operations/adoption-guide/#phase-1-canon-establishment","title":"Phase 1 \u2014 Canon Establishment","text":"<p>Objective: Define structural authority.</p> <p>Actions:</p> <ul> <li>Write initial ARCHITECTURE_RULES.md</li> <li>Define precedence</li> <li>Identify protected zones</li> <li>Establish mutation protocol</li> <li>Define task groups</li> </ul> <p>Focus: Clarity over completeness.</p> <p>This phase moves the team from Level 0 to Level 1 maturity.</p>"},{"location":"operations/adoption-guide/#phase-2-spec-discipline","title":"Phase 2 \u2014 Spec Discipline","text":"<p>Objective: Separate planning from execution.</p> <p>Actions:</p> <ul> <li>Enforce spec-first workflow</li> <li>Require requirements.md, design.md, tasks.md</li> <li>Introduce HITL approval gate</li> <li>Prevent execution before approval</li> </ul> <p>Focus: Temporal governance.</p> <p>This phase prevents architecture from emerging implicitly.</p>"},{"location":"operations/adoption-guide/#phase-3-structured-enforcement","title":"Phase 3 \u2014 Structured Enforcement","text":"<p>Objective: Formalize rule validation.</p> <p>Actions:</p> <ul> <li>Introduce Rule Schema v2</li> <li>Implement Canon Compiler</li> <li>Generate enforcement matrix</li> <li>Require compiler validation before execution</li> </ul> <p>Focus: Mechanical integrity.</p> <p>This phase moves governance from advisory to enforceable.</p>"},{"location":"operations/adoption-guide/#phase-4-observability","title":"Phase 4 \u2014 Observability","text":"<p>Objective: Detect slow drift.</p> <p>Actions:</p> <ul> <li>Implement Policy Engine</li> <li>Log refusal frequency</li> <li>Track shadow pattern detection</li> <li>Monitor mutation frequency</li> <li>Establish governance review cadence</li> </ul> <p>Focus: Proactive stability.</p> <p>This phase moves the system from reactive to preventative.</p>"},{"location":"operations/adoption-guide/#phase-5-deterministic-continuity","title":"Phase 5 \u2014 Deterministic Continuity","text":"<p>Objective: Guarantee reproducibility.</p> <p>Actions:</p> <ul> <li>Log canon version per execution</li> <li>Enforce handover protocol</li> <li>Validate multi-model consistency</li> <li>Require full spec discipline</li> </ul> <p>Focus: Long-term structural stability.</p> <p>This phase completes Level 4 maturity.</p>"},{"location":"operations/adoption-guide/#organizational-role-alignment","title":"Organizational Role Alignment","text":"<p>SAGT does not require new job titles.</p> <p>It clarifies responsibilities:</p> <ul> <li>Architects define canon.</li> <li>Developers write specs.</li> <li>Agents execute under governance.</li> <li>Humans approve mutation.</li> <li>Policy monitors system health.</li> </ul> <p>Authority remains layered.</p>"},{"location":"operations/adoption-guide/#resistance-patterns","title":"Resistance Patterns","text":"<p>Common resistance includes:</p> <ul> <li>\u201cThis slows us down.\u201d</li> <li>\u201cThe agent already does this.\u201d</li> <li>\u201cWe can just be careful.\u201d</li> <li>\u201cThis is too formal.\u201d</li> </ul> <p>Governance friction occurs only during transition.</p> <p>Long-term velocity increases because drift decreases.</p>"},{"location":"operations/adoption-guide/#common-adoption-mistakes","title":"Common Adoption Mistakes","text":"<ol> <li>Skipping protected zone definition.</li> <li>Treating mutation as minor change.</li> <li>Allowing skill authority creep.</li> <li>Ignoring refusal events.</li> <li>Collecting policy metrics but not reviewing them.</li> <li>Weakening HITL enforcement.</li> </ol> <p>Governance discipline must remain</p>"},{"location":"operations/compliance-mapping/","title":"Compliance &amp; Audit Mapping","text":"<p>SAGT is not a compliance standard.</p> <p>However, its governance structure can be mapped to common assurance frameworks such as:</p> <ul> <li>ISO-style governance controls</li> <li>SOC-style internal control systems</li> <li>Change management standards</li> <li>Secure development lifecycle models</li> <li>Risk management frameworks</li> </ul> <p>This document explains how SAGT aligns structurally with audit expectations.</p>"},{"location":"operations/compliance-mapping/#why-compliance-mapping-matters","title":"Why Compliance Mapping Matters","text":"<p>Enterprise adoption requires:</p> <ul> <li>Traceability</li> <li>Version control</li> <li>Change approval records</li> <li>Structural integrity checks</li> <li>Enforcement evidence</li> <li>Deterministic process controls</li> </ul> <p>SAGT provides these structurally.</p> <p>Mapping makes them visible to auditors.</p>"},{"location":"operations/compliance-mapping/#governance-as-control-system","title":"Governance as Control System","text":"<p>SAGT can be viewed as a layered control system:</p> <ul> <li>Canon \u2192 Policy Definition Layer</li> <li>Compiler \u2192 Structural Validation Layer</li> <li>Spec Workflow \u2192 Change Management Layer</li> <li>HITL \u2192 Approval Control Layer</li> <li>Mutation \u2192 Formal Change Control</li> <li>Policy Engine \u2192 Continuous Monitoring</li> <li>Handover \u2192 State Continuity &amp; Traceability</li> </ul> <p>This structure parallels formal governance models.</p>"},{"location":"operations/compliance-mapping/#change-management-mapping","title":"Change Management Mapping","text":"<p>Traditional change management requires:</p> <ul> <li>Defined request</li> <li>Impact analysis</li> <li>Approval</li> <li>Version control</li> <li>Documentation</li> <li>Audit trail</li> </ul> <p>SAGT provides:</p> <ul> <li>Spec-first workflow (requirements/design/tasks)</li> <li>Mutation protocol</li> <li>Canon version increment</li> <li>Compiler validation</li> <li>HITL approval gate</li> <li>Execution logs</li> </ul> <p>SAGT change control is deterministic and logged.</p>"},{"location":"operations/compliance-mapping/#access-authority-mapping","title":"Access &amp; Authority Mapping","text":"<p>Compliance frameworks require:</p> <ul> <li>Defined roles</li> <li>Controlled authority</li> <li>Restricted modification rights</li> <li>Explicit privilege escalation</li> </ul> <p>SAGT enforces:</p> <ul> <li>Task Group boundaries</li> <li>Protected zones</li> <li>Security model declaration</li> <li>Mutation-only structural changes</li> <li>HITL for authority escalation</li> </ul> <p>Authority is layered and explicit.</p>"},{"location":"operations/compliance-mapping/#auditability","title":"Auditability","text":"<p>Audit requires:</p> <ul> <li>Evidence of rule enforcement</li> <li>Traceable changes</li> <li>Logged decisions</li> <li>Deterministic reproduction</li> </ul> <p>SAGT supports:</p> <ul> <li>Canon version logging</li> <li>Enforcement matrix</li> <li>Mutation history</li> <li>Policy telemetry logs</li> <li>Handover records</li> <li>Structured rule IDs</li> </ul> <p>Execution can be replayed against canon version.</p>"},{"location":"operations/compliance-mapping/#risk-management-mapping","title":"Risk Management Mapping","text":"<p>Risk frameworks require:</p> <ul> <li>Identification of structural risks</li> <li>Mitigation controls</li> <li>Continuous monitoring</li> <li>Escalation triggers</li> </ul> <p>SAGT provides:</p> <ul> <li>Protected zones</li> <li>Policy thresholds</li> <li>Shadow pattern detection</li> <li>Refusal enforcement</li> <li>Hard escalation via HITL</li> </ul> <p>Risk is structurally mitigated.</p>"},{"location":"operations/compliance-mapping/#secure-development-lifecycle-alignment","title":"Secure Development Lifecycle Alignment","text":"<p>Secure SDLC models require:</p> <ul> <li>Threat modeling</li> <li>Boundary enforcement</li> <li>Controlled changes</li> <li>Review gates</li> <li>Logging</li> </ul> <p>SAGT integrates:</p> <ul> <li>Security model in canon</li> <li>Protected security zones</li> <li>Mutation review</li> <li>Spec-first review</li> <li>HITL escalation</li> <li>Version traceability</li> </ul> <p>Security is canonical, not optional.</p>"},{"location":"operations/compliance-mapping/#determinism-as-control-assurance","title":"Determinism as Control Assurance","text":"<p>Compliance requires predictability.</p> <p>SAGT enforces:</p> <ul> <li>Deterministic rule resolution</li> <li>Structured precedence</li> <li>Compiler validation</li> <li>Mutation versioning</li> </ul> <p>This enables reproducible governance outcomes.</p>"},{"location":"operations/compliance-mapping/#governance-evidence-artifacts","title":"Governance Evidence Artifacts","text":"<p>For audit purposes, SAGT can produce:</p> <ul> <li>Canon version history</li> <li>Mutation log</li> <li>Enforcement matrix export</li> <li>Policy metric reports</li> <li>Refusal frequency report</li> <li>HITL event log</li> <li>Spec archive</li> </ul> <p>These artifacts support governance verification.</p>"},{"location":"operations/compliance-mapping/#what-sagt-does-not-replace","title":"What SAGT Does Not Replace","text":"<p>SAGT does not replace:</p> <ul> <li>Legal compliance review</li> <li>External audit processes</li> <li>Human risk assessment</li> <li>Regulatory interpretation</li> </ul> <p>It provides structural governance for</p>"},{"location":"operations/maturity-model/","title":"Governance Maturity Model","text":"<p>The Governance Maturity Model defines progressive levels of SAGT adoption.</p> <p>It allows teams to assess:</p> <ul> <li>Structural stability</li> <li>Drift resistance</li> <li>Enforcement consistency</li> <li>Mutation discipline</li> <li>Determinism guarantees</li> </ul> <p>Maturity is not about complexity. It is about structural integrity.</p>"},{"location":"operations/maturity-model/#level-0-informal-governance","title":"Level 0 \u2014 Informal Governance","text":"<p>Characteristics:</p> <ul> <li>No explicit canon.</li> <li>Architecture evolves implicitly.</li> <li>Agents optimize locally.</li> <li>No refusal model.</li> <li>No mutation workflow.</li> <li>No deterministic guarantees.</li> </ul> <p>At this level:</p> <ul> <li>Drift is continuous.</li> <li>Security assumptions are implicit.</li> <li>Architectural decisions accumulate without review.</li> </ul> <p>Most AI-assisted projects operate here.</p>"},{"location":"operations/maturity-model/#level-1-canon-defined","title":"Level 1 \u2014 Canon Defined","text":"<p>Characteristics:</p> <ul> <li>Canon documents exist.</li> <li>Precedence is declared.</li> <li>Protected zones are defined.</li> <li>Mutation workflow exists.</li> </ul> <p>Limitations:</p> <ul> <li>No compiler validation.</li> <li>Policy metrics not tracked.</li> <li>HITL may be inconsistent.</li> <li>Skills may overreach occasionally.</li> </ul> <p>This level prevents obvious drift but not subtle erosion.</p>"},{"location":"operations/maturity-model/#level-2-structured-enforcement","title":"Level 2 \u2014 Structured Enforcement","text":"<p>Characteristics:</p> <ul> <li>Canon includes structured rule blocks.</li> <li>Canon Compiler validates integrity.</li> <li>Enforcement matrix generated.</li> <li>Refusal model consistently applied.</li> <li>HITL protocol enforced strictly.</li> </ul> <p>At this level:</p> <ul> <li>Canon contradictions are caught automatically.</li> <li>Protected zone modifications require mutation.</li> <li>Structural violations halt execution.</li> </ul> <p>Governance is mechanically enforced.</p>"},{"location":"operations/maturity-model/#level-3-observability-enabled","title":"Level 3 \u2014 Observability Enabled","text":"<p>Characteristics:</p> <ul> <li>Policy Engine active.</li> <li>Telemetry logged.</li> <li>Refusal rates tracked.</li> <li>Shadow patterns detected.</li> <li>Mutation frequency monitored.</li> <li>TTL review active.</li> </ul> <p>At this level:</p> <ul> <li>Drift is detected before it accumulates.</li> <li>Governance pressure is visible.</li> <li>Structural instability trends are measurable.</li> </ul> <p>Governance becomes proactive.</p>"},{"location":"operations/maturity-model/#level-4-deterministic-continuity","title":"Level 4 \u2014 Deterministic Continuity","text":"<p>Characteristics:</p> <ul> <li>Canon version logged per execution.</li> <li>Handover protocol consistently applied.</li> <li>Multi-model continuity validated.</li> <li>Spec-first strictly enforced.</li> <li>Compiler required before execution.</li> </ul> <p>At this level:</p> <ul> <li>Reproducibility is guaranteed.</li> <li>Model switching does not alter outcomes.</li> <li>Structural divergence is traceable.</li> <li>Governance survives time.</li> </ul> <p>This is production-grade governance.</p>"},{"location":"operations/maturity-model/#level-5-adaptive-governance","title":"Level 5 \u2014 Adaptive Governance","text":"<p>Characteristics:</p> <ul> <li>Mutation is minimal and deliberate.</li> <li>Policy thresholds tuned empirically.</li> <li>Shadow pressure used to evolve canon intentionally.</li> <li>Governance review cadence institutionalized.</li> <li>Compiler schema evolves under mutation discipline.</li> </ul> <p>At this level:</p> <ul> <li>Governance adapts without drifting.</li> <li>Evolution is structured.</li> <li>Stability and flexibility coexist.</li> </ul> <p>Very few systems reach this level.</p>"},{"location":"operations/maturity-model/#why-maturity-matters","title":"Why Maturity Matters","text":"<p>Governance is binary in theory but gradual in practice.</p> <p>A team may believe they are governed while operating at Level 1.</p> <p>The maturity model provides:</p> <ul> <li>Honest assessment</li> <li>Roadmap for improvement</li> <li>Audit framework</li> <li>Organizational alignment</li> </ul>"},{"location":"operations/maturity-model/#anti-patterns-by-level","title":"Anti-Patterns by Level","text":"<p>Level 0: - \"The agent usually does the right thing.\"</p> <p>Level 1: - Canon exists but mutation is casual.</p> <p>Level 2: - Compiler active but policy ignored.</p> <p>Level 3: - Metrics collected but not reviewed.</p> <p>Level 4: - Determinism claimed but not logged.</p> <p>Level 5: - Mutation becomes frequent again (</p>"},{"location":"operations/playbook/","title":"Operational Playbook","text":"<p>The Operational Playbook defines how SAGT is used in real development environments.</p> <p>Governance is not theoretical. It must be executable day-to-day.</p> <p>This document explains how teams and agents interact with SAGT in practice.</p>"},{"location":"operations/playbook/#1-bootstrapping-a-new-project","title":"1. Bootstrapping a New Project","text":"<p>When initializing a project under SAGT:</p> <ol> <li>Clone the Sovereign Agent Template.</li> <li>Define project-specific canon extensions (if required).</li> <li>Confirm protected zones.</li> <li>Validate compiler.</li> <li>Establish policy thresholds.</li> <li>Perform initial governance audit.</li> </ol> <p>No implementation begins before governance is stable.</p> <p>SAGT treats governance initialization as infrastructure, not ceremony.</p>"},{"location":"operations/playbook/#2-daily-execution-flow","title":"2. Daily Execution Flow","text":"<p>When a new request is made:</p> <ol> <li>Agent classifies Task Group.</li> <li>Canon state validated.</li> <li>Spec required? If yes \u2192 generate.</li> <li>Await approval.</li> <li>Execute tasks.</li> <li>Log telemetry.</li> <li>Evaluate policy.</li> <li>Update handover (if incomplete).</li> </ol> <p>The lifecycle is invariant.</p> <p>No shortcutting.</p>"},{"location":"operations/playbook/#3-when-refusal-occurs","title":"3. When Refusal Occurs","text":"<p>If refusal is triggered:</p> <ul> <li>Stop immediately.</li> <li>Identify the violated rule.</li> <li>Determine whether mutation is required.</li> <li>If ambiguity exists \u2192 HITL.</li> </ul> <p>Refusal must be logged.</p> <p>Repeated refusal patterns should be reviewed under Policy.</p>"},{"location":"operations/playbook/#4-when-mutation-is-required","title":"4. When Mutation Is Required","text":"<p>Mutation is not an inconvenience. It is controlled evolution.</p> <p>Operational steps:</p> <ol> <li>Generate mutation proposal.</li> <li>Perform impact analysis.</li> <li>Validate compiler.</li> <li>Human approval.</li> <li>Version increment.</li> <li>Announce change.</li> </ol> <p>Mutation must be rare and explicit.</p>"},{"location":"operations/playbook/#5-governance-review-cadence","title":"5. Governance Review Cadence","text":"<p>SAGT recommends periodic governance review:</p> <ul> <li>Review policy metrics.</li> <li>Review mutation frequency.</li> <li>Review shadow pattern detection.</li> <li>Review refusal trends.</li> <li>Review TTL flags.</li> </ul> <p>Governance drift is gradual. Review prevents accumulation.</p>"},{"location":"operations/playbook/#6-multi-model-environments","title":"6. Multi-Model Environments","text":"<p>In multi-model environments:</p> <ul> <li>Always read canon first.</li> <li>Validate compiler status.</li> <li>Read current spec.</li> <li>Read HANDOVER.md.</li> <li>Confirm canon version.</li> </ul> <p>Never resume execution without validating authority state.</p> <p>Model switching must not alter governance behavior.</p>"},{"location":"operations/playbook/#7-emergency-governance-halt","title":"7. Emergency Governance Halt","text":"<p>If systemic instability is detected:</p> <ul> <li>Freeze execution.</li> <li>Lock mutation.</li> <li>Audit canon.</li> <li>Review policy metrics.</li> <li>Resolve structural conflicts.</li> </ul> <p>Resuming execution without structural repair compounds instability.</p>"},{"location":"operations/playbook/#8-handling-shadow-pressure","title":"8. Handling Shadow Pressure","text":"<p>If shadow pattern attempts increase:</p> <ul> <li>Review canon clarity.</li> <li>Evaluate skill constraints.</li> <li>Determine if mutation is warranted.</li> <li>Avoid silent relaxation of governance.</li> </ul> <p>Shadow pressure signals architectural tension.</p> <p>It should be examined, not suppressed.</p>"},{"location":"operations/playbook/#9-version-management","title":"9. Version Management","text":"<p>Canon version must be:</p> <ul> <li>Logged in execution output.</li> <li>Referenced in spec.</li> <li>Stored in HANDOVER.md.</li> <li>Included in telemetry.</li> </ul> <p>Version</p>"},{"location":"operations/stress-scenarios/","title":"Governance Stress Scenarios","text":"<p>Governance is tested under pressure.</p> <p>SAGT is designed not only for ideal conditions, but for conflict, ambiguity, mutation pressure, and model divergence.</p> <p>This document outlines realistic stress cases and the expected structural response.</p>"},{"location":"operations/stress-scenarios/#scenario-1-canon-conflict-emerges","title":"Scenario 1 \u2014 Canon Conflict Emerges","text":"<p>Situation: Two canonical rules conflict at equal precedence.</p> <p>Example: - Rule A requires strict error propagation. - Rule B allows silent fallback behavior. - Both share identical precedence.</p> <p>Expected Behavior:</p> <ol> <li>Canon Compiler detects equal-precedence conflict.</li> <li>Compilation fails.</li> <li>Execution halts.</li> <li>Agent emits:</li> </ol> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Resolution requires: - Mutation to clarify precedence. - Version increment. - Recompilation.</p> <p>SAGT does not auto-resolve equal-precedence ambiguity.</p>"},{"location":"operations/stress-scenarios/#scenario-2-implementation-task-reveals-architectural-defect","title":"Scenario 2 \u2014 Implementation Task Reveals Architectural Defect","text":"<p>Situation: During implementation, the agent discovers that a structural invariant must change.</p> <p>Expected Behavior:</p> <ol> <li>Skill detects protected zone interaction.</li> <li>Execution halts.</li> <li>Task Group reclassification required.</li> <li>Mutation workflow initiated.</li> <li>HITL required.</li> </ol> <p>Improper Behavior (prohibited): - Quietly modifying the invariant. - Adjusting canon indirectly. - Continuing execution under assumption.</p> <p>Architecture must never evolve inside implementation.</p>"},{"location":"operations/stress-scenarios/#scenario-3-shadow-pattern-pressure","title":"Scenario 3 \u2014 Shadow Pattern Pressure","text":"<p>Situation: Multiple executions attempt to introduce a new architectural abstraction.</p> <p>Policy metrics show:</p> <ul> <li>Shadow pattern detection &gt; threshold.</li> <li>Repeated mutation proposals for same pattern.</li> </ul> <p>Expected Behavior:</p> <ol> <li>Policy triggers escalation.</li> <li>Governance review required.</li> <li>Evaluate whether canon is incomplete.</li> <li>Decide:    A) Reject pattern permanently.    B) Formalize pattern through mutation.</li> </ol> <p>Silent normalization is forbidden.</p> <p>Shadow pressure is structural signal.</p>"},{"location":"operations/stress-scenarios/#scenario-4-rapid-mutation-frequency","title":"Scenario 4 \u2014 Rapid Mutation Frequency","text":"<p>Situation: Multiple canon mutations occur within short timeframe.</p> <p>Possible Causes:</p> <ul> <li>Incomplete initial governance modeling.</li> <li>Architectural instability.</li> <li>Overly rigid constraints.</li> <li>Improper task classification.</li> </ul> <p>Expected Behavior:</p> <ol> <li>Policy detects mutation frequency spike.</li> <li>Hard escalation triggered.</li> <li>Governance review conducted.</li> <li>Canon stability evaluated.</li> </ol> <p>Mutation must remain deliberate and rare.</p>"},{"location":"operations/stress-scenarios/#scenario-5-multi-model-divergence","title":"Scenario 5 \u2014 Multi-Model Divergence","text":"<p>Situation: Model A and Model B produce different structural outcomes for identical spec and canon.</p> <p>Expected Behavior:</p> <ol> <li>Compare canonical citations.</li> <li>Validate compiler output.</li> <li>Confirm determinism boundary.</li> <li>Identify divergence source.</li> <li>Possibly strengthen canon</li> </ol>"},{"location":"overview/execution-lifecycle/","title":"Execution Lifecycle","text":"<p>SAGT enforces a deterministic execution pipeline.</p> <p>Every request flows through the same stages.</p> <p>No stage may be skipped.</p>"},{"location":"overview/execution-lifecycle/#1-classify-task-group","title":"1. Classify Task Group","text":"<p>The agent classifies the request into exactly one task group.</p> <p>If classification is ambiguous: the agent halts and emits:</p> <p>[AWAIT_HUMAN_VALIDATION]</p>"},{"location":"overview/execution-lifecycle/#2-validate-canon-state","title":"2. Validate Canon State","text":"<p>Before planning or execution: - Precedence is evaluated - Canon conflicts are checked - Protected zones are verified - Compiler validity is confirmed (if enabled)</p> <p>If canon is unstable: execution halts.</p>"},{"location":"overview/execution-lifecycle/#3-determine-spec-requirement","title":"3. Determine Spec Requirement","text":"<p>If work is non-trivial: the agent generates a spec set:</p> <ul> <li>requirements.md</li> <li>design.md</li> <li>tasks.md</li> </ul> <p>If canon explicitly permits trivial execution: spec may be skipped.</p> <p>Spec requirement is derived from canon, not inferred.</p>"},{"location":"overview/execution-lifecycle/#4-hitl-gate-when-required","title":"4. HITL Gate (When Required)","text":"<p>The agent must stop and request validation when: - protected zones are touched - security boundaries are ambiguous - canon conflicts exist - mutation is required - policy thresholds are exceeded</p> <p>The agent emits:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Execution does not continue.</p>"},{"location":"overview/execution-lifecycle/#5-execute-tasks","title":"5. Execute Tasks","text":"<p>Tasks execute only within: - the chosen task group - canon boundaries - skill authority limits</p> <p>If a task requires new architectural judgment: execution halts and the agent escalates.</p>"},{"location":"overview/execution-lifecycle/#6-log-telemetry","title":"6. Log Telemetry","text":"<p>Execution records: - task group - skills used - canon references (where applicable) - refusal events - HITL events - mutation attempts</p> <p>Governance without observability is incomplete.</p>"},{"location":"overview/execution-lifecycle/#7-evaluate-policy","title":"7. Evaluate Policy","text":"<p>Policy checks drift signals such as: - refusal frequency - shadow pattern attempts - mutation frequency - protected zone touch attempts</p> <p>If thresholds are exceeded: execution halts and escalates.</p>"},{"location":"overview/execution-lifecycle/#8-update-handover-state","title":"8. Update Handover State","text":"<p>If execution is incomplete: the agent updates <code>.jtasks/HANDOVER.md</code>.</p> <p>Handover enables multi-model continuity.</p> <p>Governance must survive context loss.</p>"},{"location":"overview/introduction/","title":"Introduction","text":"<p>Sovereign Agent Template (SAGT) is a governance framework for AI coding agents.</p> <p>Its purpose is to prevent architectural drift, security assumption creep, and undocumented pattern adoption during AI-assisted development.</p> <p>SAGT treats documentation as enforceable authority. Agents are constrained by canon. Execution is deterministic and auditable.</p> <p>This site documents SAGT as a system: - What it is - Why it exists - How it enforces boundaries - How it evolves safely</p> <p>SAGT does not define your product architecture. It defines how product architecture is allowed to be defined.</p> <p>Governance precedes generation.</p>"},{"location":"overview/introduction/#what-sagt-solves","title":"What SAGT Solves","text":"<p>AI agents tend to: - Fill missing gaps with plausible assumptions - Adopt patterns not approved by the repo - Blend architecture and implementation - Continue under ambiguity</p> <p>SAGT prevents this by enforcing: - Canon precedence - Task group exclusivity - Procedural-only skills - Spec-first execution - HITL escalation - Policy monitoring - Canon compilation</p>"},{"location":"overview/introduction/#how-to-read-this-documentation","title":"How to Read This Documentation","text":"<p>If you are new to SAGT:</p> <ol> <li>Read Core Principles</li> <li>Read Execution Lifecycle</li> <li>Read Canon and Protected Zones</li> <li>Read Spec Workflow and HITL</li> <li>Read Mutation and Policy Engine</li> </ol> <p>If you are implementing tooling: - Start at Canon Compiler and Rule Schema v2</p> <p>If you are adopting SAGT in a team: - Start at Operations \u2192 Adoption Guide</p> <p>SAGT is governance infrastructure.</p> <p>It is designed to be stable, portable, and replaceable across projects.</p>"},{"location":"overview/principles/","title":"Core Principles","text":"<p>SAGT is built on a small set of strict principles.</p> <p>These are not guidance. They are enforcement targets.</p>"},{"location":"overview/principles/#canon-first","title":"Canon First","text":"<p>Canonical documents define authority.</p> <p>Higher precedence overrides lower precedence.</p> <p>If two rules conflict and precedence does not resolve it: execution halts.</p> <p>Agents do not reconcile ambiguous law.</p>"},{"location":"overview/principles/#one-task-group-per-execution","title":"One Task Group Per Execution","text":"<p>Every request must be classified into exactly one task group.</p> <p>If classification is ambiguous: execution halts.</p> <p>Mixed task groups are not allowed because they collapse separation of concerns.</p>"},{"location":"overview/principles/#skills-are-procedural-only","title":"Skills Are Procedural Only","text":"<p>Skills execute known procedures.</p> <p>Skills cannot: - Introduce architecture - Modify canon - Alter invariants - Override enforcement rules - Fill missing security boundaries</p> <p>If a skill encounters design judgment: it must stop.</p>"},{"location":"overview/principles/#spec-first-for-non-trivial-work","title":"Spec-First for Non-Trivial Work","text":"<p>Non-trivial work requires:</p> <ol> <li>requirements.md</li> <li>design.md</li> <li>tasks.md</li> </ol> <p>Execution begins only after explicit instruction.</p> <p>Spec-first separates planning from doing.</p>"},{"location":"overview/principles/#refusal-preserves-integrity","title":"Refusal Preserves Integrity","text":"<p>Refusal is a feature.</p> <p>Refusal occurs when: - Canon is violated - Security assumptions are undefined - Task group classification is ambiguous - Protected zones would be modified - Determinism cannot be guaranteed</p> <p>A governed agent must refuse.</p>"},{"location":"overview/principles/#determinism-is-required","title":"Determinism Is Required","text":"<p>Given: - Same canon version - Same spec - Same inputs</p> <p>Execution must converge to equivalent output.</p> <p>If determinism cannot be guaranteed: execution halts.</p>"},{"location":"overview/principles/#human-validation-is-structural","title":"Human Validation Is Structural","text":"<p>When a decision exceeds delegated authority, the agent emits:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Execution stops immediately.</p> <p>This is machine-detectable and must not be bypassed.</p>"},{"location":"policy/","title":"Policy Engine","text":"<p>The Policy Engine monitors governance health over time.</p> <p>Canon defines rules. Task Groups enforce separation. Skills constrain procedure. Spec controls time.</p> <p>Policy observes patterns.</p> <p>Policy does not define authority. It detects structural stress.</p>"},{"location":"policy/#why-policy-exists","title":"Why Policy Exists","text":"<p>Even with strict canon and enforcement, systems degrade gradually.</p> <p>Degradation rarely occurs through direct violation. It occurs through pattern accumulation.</p> <p>Examples:</p> <ul> <li>Repeated near-boundary decisions.</li> <li>Frequent shadow pattern attempts.</li> <li>Escalating mutation frequency.</li> <li>Increasing refusal loops.</li> <li>Canon TTL stagnation.</li> </ul> <p>Policy detects these slow drifts before they become structural failure.</p>"},{"location":"policy/#canon-vs-policy","title":"Canon vs Policy","text":"<p>Canon is deterministic and rule-based.</p> <p>Policy is pattern-based and threshold-driven.</p> <p>Canon answers: \"Is this allowed?\"</p> <p>Policy answers: \"Is the system stable?\"</p> <p>Policy never overrides canon. It escalates when stability degrades.</p>"},{"location":"policy/#policy-metrics","title":"Policy Metrics","text":"<p>Policy evaluates structured telemetry from execution.</p> <p>Common metrics include:</p> <ul> <li>Refusal frequency (windowed)</li> <li>Shadow pattern detection count</li> <li>Mutation frequency</li> <li>HITL trigger rate</li> <li>Canon citation coverage</li> <li>Protected Zone touch attempts</li> <li>Spec bypass attempts</li> <li>Task Group misclassification events</li> </ul> <p>Metrics must be measurable and logged.</p>"},{"location":"policy/#thresholds","title":"Thresholds","text":"<p>Each metric has defined thresholds.</p> <p>Example:</p> <ul> <li>Refusal rate &gt; 20% over last 50 executions</li> <li>Shadow attempts &gt; 5 within rolling window</li> <li>Mutation frequency &gt; 3 per sprint</li> <li>Canon citation coverage &lt; 60%</li> </ul> <p>Thresholds must be declared in canon or policy configuration.</p> <p>Thresholds are not inferred by the agent.</p>"},{"location":"policy/#escalation-semantics","title":"Escalation Semantics","text":"<p>When a threshold is exceeded:</p> <p>The agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Escalation halts execution.</p> <p>Policy escalation requires review of:</p> <ul> <li>Canon completeness</li> <li>Governance rigidity</li> <li>Skill overreach</li> <li>Architectural pressure</li> </ul> <p>Escalation is not punishment. It is system health review.</p>"},{"location":"policy/#soft-vs-hard-escalation","title":"Soft vs Hard Escalation","text":"<p>Soft Escalation: - Warning state logged - Execution may continue - Policy report generated</p> <p>Hard Escalation: - Execution halts - HITL required - Governance review mandatory</p> <p>Escalation type must be declared explicitly.</p>"},{"location":"policy/#policy-and-shadow-pressure","title":"Policy and Shadow Pressure","text":"<p>High shadow frequency may indicate:</p> <ul> <li>Canon gaps</li> <li>Legitimate architectural evolution pressure</li> <li>Skill authority misalignment</li> <li>Missing mutation pathways</li> </ul> <p>Policy surfaces tension.</p> <p>It does not resolve it automatically.</p>"},{"location":"policy/#policy-and-mutation-frequency","title":"Policy and Mutation Frequency","text":"<p>Excessive mutation may signal:</p> <ul> <li>Incomplete initial governance modeling</li> <li>Overly rigid canon</li> <li>Architectural instability</li> </ul> <p>Too little mutation may signal:</p> <ul> <li>Governance stagnation</li> <li>Over-centralization of authority</li> <li>Suppressed evolution</li> </ul> <p>Policy balances rigidity and adaptability.</p>"},{"location":"policy/#policy-and-determinism","title":"Policy and Determinism","text":"<p>Policy does not alter execution logic.</p> <p>However, repeated escalation without mutation may produce instability.</p> <p>Policy encourages deliberate correction before deterministic divergence occurs.</p>"},{"location":"policy/#policy-failure-modes","title":"Policy Failure Modes","text":"<p>Policy becomes harmful if:</p> <ul> <li>Thresholds are vague.</li> <li>Metrics are unmeasurable.</li> <li>Escalation semantics are undefined.</li> <li>Policy overrides canon.</li> <li>Agents reinterpret thresholds dynamically.</li> </ul> <p>Policy must be rule-driven, not interpretive.</p>"},{"location":"policy/#policy-is-observability","title":"Policy Is Observability","text":"<p>Governance without observability is fragile.</p> <p>Policy provides system-level visibility into drift.</p> <p>It ensures:</p> <ul> <li>Early detection of erosion</li> <li>Structured intervention</li> <li>Long-term stability</li> </ul> <p>The Policy Engine is SAGT's immune system.</p> <p>It does not create law. It detects instability in the organism.</p>"},{"location":"reference/determinism/","title":"Determinism","text":"<p>Determinism in SAGT means:</p> <p>Given: - The same canon version - The same approved spec - The same inputs - The same task group - The same skill set</p> <p>The system must converge toward equivalent output.</p> <p>If this guarantee cannot be upheld, execution must halt.</p> <p>Determinism is not about identical token output. It is about structural equivalence under identical authority conditions.</p>"},{"location":"reference/determinism/#why-determinism-matters","title":"Why Determinism Matters","text":"<p>AI systems are probabilistic.</p> <p>Without deterministic governance:</p> <ul> <li>Architectural outcomes drift across sessions.</li> <li>Multi-model execution diverges.</li> <li>Mutation becomes untraceable.</li> <li>Auditability collapses.</li> <li>Long-term stability degrades.</li> </ul> <p>Determinism transforms probabilistic reasoning into governed structure.</p>"},{"location":"reference/determinism/#determinism-boundaries","title":"Determinism Boundaries","text":"<p>SAGT does not require byte-level equality.</p> <p>It requires:</p> <ul> <li>Equivalent structural decisions</li> <li>Equivalent enforcement adherence</li> <li>Equivalent invariant preservation</li> <li>Equivalent task ordering</li> </ul> <p>Stylistic differences are acceptable. Structural divergence is not.</p>"},{"location":"reference/determinism/#sources-of-non-determinism","title":"Sources of Non-Determinism","text":"<p>Common sources include:</p> <ul> <li>Ambiguous canon rules</li> <li>Equal-precedence conflicts</li> <li>Implicit architectural assumptions</li> <li>Missing enforcement semantics</li> <li>Skill authority expansion</li> <li>Untracked mutation</li> <li>Policy threshold drift</li> <li>Context-dependent reasoning</li> </ul> <p>SAGT detects these conditions and halts execution.</p>"},{"location":"reference/determinism/#determinism-enforcement-mechanisms","title":"Determinism Enforcement Mechanisms","text":"<p>Determinism is preserved through:</p> <ul> <li>Canon precedence enforcement</li> <li>Structured rule compilation</li> <li>Protected zones</li> <li>Spec-first workflow</li> <li>Explicit task group classification</li> <li>Skill authority limits</li> <li>HITL escalation</li> <li>Handover state externalization</li> <li>Canon version logging</li> </ul> <p>Each mechanism removes hidden variability.</p>"},{"location":"reference/determinism/#determinism-and-versioning","title":"Determinism and Versioning","text":"<p>Canon version must be recorded in every execution log.</p> <p>Two executions using different canon versions are not required to match.</p> <p>Determinism is scoped to canon version.</p> <p>Mutation introduces new determinism boundaries.</p>"},{"location":"reference/determinism/#determinism-and-multi-model-execution","title":"Determinism and Multi-Model Execution","text":"<p>SAGT is model-agnostic.</p> <p>If two different models execute:</p> <ul> <li>They must converge structurally.</li> <li>If divergence occurs, governance failure exists.</li> </ul> <p>Differences in reasoning language are irrelevant. Differences in structural decisions are not.</p>"},{"location":"reference/determinism/#determinism-failure-behavior","title":"Determinism Failure Behavior","text":"<p>If determinism cannot be guaranteed:</p> <ul> <li>The agent must halt.</li> <li>Emit:</li> </ul> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>Execution must not proceed under uncertainty.</p> <p>Continuing would introduce hidden authority.</p>"},{"location":"reference/determinism/#determinism-is-structural-not-behavioral","title":"Determinism Is Structural, Not Behavioral","text":"<p>SAGT governs structure, not creativity.</p> <p>Agents may vary in explanation style. They may vary in wording. They may vary in minor formatting.</p> <p>They must not vary in:</p> <ul> <li>Invariant enforcement</li> <li>Protected zone respect</li> <li>Mutation process adherence</li> <li>Task group isolation</li> </ul>"},{"location":"reference/determinism/#determinism-and-long-term-stability","title":"Determinism and Long-Term Stability","text":"<p>Determinism ensures:</p> <ul> <li>Reproducible builds</li> <li>Auditable governance history</li> <li>Safe model upgrades</li> <li>Stable mutation cycles</li> <li>Consistent enforcement</li> </ul> <p>Without determinism, governance becomes advisory.</p> <p>Determinism is the measurable guarantee of structural stability in SAGT.</p>"},{"location":"reference/refusal-model/","title":"Refusal Model","text":"<p>Refusal is a structural enforcement mechanism.</p> <p>It exists to prevent governance violations before they propagate into architectural drift.</p> <p>Refusal is not failure. Refusal is boundary preservation.</p>"},{"location":"reference/refusal-model/#why-refusal-exists","title":"Why Refusal Exists","text":"<p>AI agents are optimized to complete tasks.</p> <p>Completion bias leads to:</p> <ul> <li>Resolving ambiguity automatically</li> <li>Filling missing assumptions</li> <li>Reconciling rule conflicts heuristically</li> <li>Continuing execution under uncertainty</li> <li>Expanding authority implicitly</li> </ul> <p>SAGT forbids this behavior.</p> <p>When authority is unclear, refusal protects structure.</p>"},{"location":"reference/refusal-model/#mandatory-refusal-conditions","title":"Mandatory Refusal Conditions","text":"<p>The agent must refuse when any of the following occur:</p> <ul> <li>Task group classification is ambiguous</li> <li>Canon conflict cannot be resolved by precedence</li> <li>Enforcement semantics are undefined</li> <li>A protected zone would be modified without mutation</li> <li>Mutation is required but not initiated</li> <li>Security boundaries are undefined</li> <li>Determinism cannot be guaranteed</li> <li>Compiler validation fails</li> <li>Policy triggers hard escalation</li> </ul> <p>These conditions are not advisory.</p> <p>They are structural enforcement points.</p>"},{"location":"reference/refusal-model/#refusal-output-requirements","title":"Refusal Output Requirements","text":"<p>Refusal must:</p> <ul> <li>Clearly state which boundary was encountered</li> <li>Reference the relevant canonical rule (if applicable)</li> <li>Avoid speculative continuation</li> <li>Avoid partial execution</li> <li>Avoid architectural suggestion beyond scope</li> </ul> <p>If human validation is required, the agent must emit:</p> <p>[AWAIT_HUMAN_VALIDATION]</p> <p>The marker must appear on its own line.</p> <p>After emission, execution must stop.</p>"},{"location":"reference/refusal-model/#refusal-vs-escalation","title":"Refusal vs Escalation","text":"<p>Refusal: Triggered by rule violation or undefined authority.</p> <p>Escalation: Triggered by systemic instability or policy thresholds.</p> <p>Both halt execution.</p> <p>The difference lies in cause: - Refusal = structural boundary - Escalation = drift detection</p>"},{"location":"reference/refusal-model/#refusal-and-skills","title":"Refusal and Skills","text":"<p>Skills must define explicit refusal triggers.</p> <p>If a skill encounters:</p> <ul> <li>Undefined canon guidance</li> <li>Protected zone interaction</li> <li>Structural design requirement</li> <li>Ambiguous enforcement behavior</li> </ul> <p>It must stop immediately.</p> <p>Skills may not attempt best-effort continuation.</p>"},{"location":"reference/refusal-model/#refusal-and-mutation","title":"Refusal and Mutation","text":"<p>When structural change is required:</p> <p>Refusal protects governance by preventing silent evolution.</p> <p>The correct next step is:</p> <ul> <li>Initiate Canon Mutation</li> <li>Or request HITL validation</li> </ul> <p>Mutation must be explicit. Refusal keeps it visible.</p>"},{"location":"reference/refusal-model/#refusal-frequency-and-policy","title":"Refusal Frequency and Policy","text":"<p>High refusal frequency does not automatically indicate failure.</p> <p>It may indicate:</p> <ul> <li>Canon incompleteness</li> <li>Overly strict constraints</li> <li>Legitimate architectural pressure</li> <li>Missing mutation pathways</li> </ul> <p>Policy monitors refusal metrics to distinguish healthy enforcement from rigidity.</p>"},{"location":"reference/refusal-model/#failure-modes-if-refusal-weakens","title":"Failure Modes if Refusal Weakens","text":"<p>If refusal softens:</p> <ul> <li>Ambiguity will be auto-resolved</li> <li>Protected zones will erode</li> <li>Mutation will become invisible</li> <li>Canon authority will degrade</li> <li>Determinism will collapse</li> </ul> <p>If refusal is overly aggressive:</p> <ul> <li>Execution may stall</li> <li>Mutation frequency may spike</li> <li>Governance may become rigid</li> </ul> <p>Balance is maintained through Policy thresholds.</p>"},{"location":"reference/refusal-model/#refusal-preserves-determinism","title":"Refusal Preserves Determinism","text":"<p>Determinism requires:</p> <ul> <li>No silent reconciliation</li> <li>No implicit authority expansion</li> <li>No structural guessing</li> </ul> <p>Refusal externalizes uncertainty.</p> <p>Without refusal, governance becomes advisory rather than enforceable.</p> <p>A governed system must sometimes say no.</p> <p>That \u201cno\u201d preserves structural integrity.</p>"}]}