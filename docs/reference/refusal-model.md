# Refusal Model

Refusal is a structural enforcement mechanism.

It exists to prevent governance violations before they propagate into architectural drift.

Refusal is not failure.
Refusal is boundary preservation.

---

## Why Refusal Exists

AI agents are optimized to complete tasks.

Completion bias leads to:

- Resolving ambiguity automatically
- Filling missing assumptions
- Reconciling rule conflicts heuristically
- Continuing execution under uncertainty
- Expanding authority implicitly

SAGT forbids this behavior.

When authority is unclear, refusal protects structure.

---

## Mandatory Refusal Conditions

The agent must refuse when any of the following occur:

- Task group classification is ambiguous
- Canon conflict cannot be resolved by precedence
- Enforcement semantics are undefined
- A protected zone would be modified without mutation
- Mutation is required but not initiated
- Security boundaries are undefined
- Determinism cannot be guaranteed
- Compiler validation fails
- Policy triggers hard escalation

These conditions are not advisory.

They are structural enforcement points.

---

## Refusal Output Requirements

Refusal must:

- Clearly state which boundary was encountered
- Reference the relevant canonical rule (if applicable)
- Avoid speculative continuation
- Avoid partial execution
- Avoid architectural suggestion beyond scope

If human validation is required, the agent must emit:

[AWAIT_HUMAN_VALIDATION]

The marker must appear on its own line.

After emission, execution must stop.

---

## Refusal vs Escalation

Refusal:
Triggered by rule violation or undefined authority.

Escalation:
Triggered by systemic instability or policy thresholds.

Both halt execution.

The difference lies in cause:
- Refusal = structural boundary
- Escalation = drift detection

---

## Refusal and Skills

Skills must define explicit refusal triggers.

If a skill encounters:

- Undefined canon guidance
- Protected zone interaction
- Structural design requirement
- Ambiguous enforcement behavior

It must stop immediately.

Skills may not attempt best-effort continuation.

---

## Refusal and Mutation

When structural change is required:

Refusal protects governance by preventing silent evolution.

The correct next step is:

- Initiate Canon Mutation
- Or request HITL validation

Mutation must be explicit.
Refusal keeps it visible.

---

## Refusal Frequency and Policy

High refusal frequency does not automatically indicate failure.

It may indicate:

- Canon incompleteness
- Overly strict constraints
- Legitimate architectural pressure
- Missing mutation pathways

Policy monitors refusal metrics to distinguish healthy enforcement from rigidity.

---

## Failure Modes if Refusal Weakens

If refusal softens:

- Ambiguity will be auto-resolved
- Protected zones will erode
- Mutation will become invisible
- Canon authority will degrade
- Determinism will collapse

If refusal is overly aggressive:

- Execution may stall
- Mutation frequency may spike
- Governance may become rigid

Balance is maintained through Policy thresholds.

---

## Refusal Preserves Determinism

Determinism requires:

- No silent reconciliation
- No implicit authority expansion
- No structural guessing

Refusal externalizes uncertainty.

Without refusal, governance becomes advisory rather than enforceable.

---

A governed system must sometimes say no.

That “no” preserves structural integrity.
